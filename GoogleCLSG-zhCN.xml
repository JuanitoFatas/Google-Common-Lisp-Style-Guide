<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="styleguide-zhCN.xsl"?>
<GUIDE title="Google Common Lisp 风格指南">
<div align="center">
  <p>
    <a HREF="https://google-styleguide.googlecode.com/svn/trunk/lispguide.xml" 
      TARGET="_blank">
    Google Common Lisp Style Guide Rev. 1.15</a> in Chinese.
    License: 
    <a HREF="http://creativecommons.org/licenses/by/3.0/" TARGET="_blank">CC-By 3.0</a>.
  </p>
</div>

<p align="right">
修订版号 1.15
</p>


<address>
Robert Brown
</address>
<address>
  <a HREF="mailto:tunes@google.com">Fran&#231;ois-Ren&#233; Rideau</a>
</address>

<address>
   纪念 Dan Weinreb
</address>

<p align="center">
<cite>模式意味著 "我的语言不够用了。"</cite> &#8212; Rich Hickey
</p>


<OVERVIEW>
<CATEGORY title="重要注意事项">
  <STYLEPOINT title="注意：显示在本指南里所隐藏的信息">
     <SUMMARY>
        这个风格指南包含了许多从外表所隐藏的细节。
        他们由三角图示标记，可以在左边看到。
        按下它。你应该看到“万岁”出现在下方。
     </SUMMARY>
     <BODY>
       <p>
        万岁！现在你知道如何将点展开来获得更多细节。
        在文件的最上方也有一个"全部展开"的按钮。
       </p>
     </BODY>
  </STYLEPOINT>
</CATEGORY>
<CATEGORY title="背景">
  <p>
    Common Lisp 是一个强大的多范式程序语言。
    能力越强，责任越大。  
  </p>
  <p>
    这个指南推荐了推荐了格式化及风格化的选择，目的在于使你的代码更容易令其他人理解。
    这些准则适用于我们在 Google 所有用 Common Lisp 写的代码，
    包括了我们维护、发布的内部应用及免费软件函式库。
    如果你想贡献代码到这个代码库，在你可以提交补丁之前，
    你必须遵循这些准则，否则你需要先修订你的代码，使其符合准则，接著再提交。
  </p>
  <p>
    如果你是在 Google 以外的地方编写 Common Lisp 代码
    我们邀请你一同来思考这里所阐述的准则。
    在你闲暇之馀，也许可以将这些准则，应用至你某些或全部的项目：
    我们希望你和我们一样，发现这些准则是很有用的。
    即便你不这么觉得，我们欢迎你评论以及提供建设性的反馈，
    来帮助我们改善这篇指南，并提供其他成功案例的风格。
    最后，我们希望激发阅读这篇指南的黑客，一些有用的想法，
    尤其是新认识 Common Lisp 的人。
  </p>
  <p>
    本指南不是一个 Common Lisp 教程。
    关于语言的基本信息，请查阅 
    <a HREF="http://www.gigamonkeys.com/book/">Practical Common Lisp</a>。
    关于语言参考手册，请查阅 
    <a HREF="http://www.lispworks.com/documentation/HyperSpec/Front/index.htm">Common Lisp HyperSpec</a>。
    关于更详细的风格指南，请看 Peter Norvig 及 Kent Pitman 的
    <a HREF="http://norvig.com/luv-slides.ps">风格指南</a>。
  </p>
</CATEGORY>
</OVERVIEW>
<CATEGORY title="元準則">
  <STYLEPOINT title="必须、应该、可能、别">
    <SUMMARY>
     每一个准则的重要程度由下列来自
     <a href="http://www.ietf.org/rfc/rfc2119.txt">RFC 2119</a> 的关键字及词组标示。
      
    </SUMMARY>
    <BODY>
      <table>
        <tr>
          <th valign="top">必须 MUST</th>
          <td>
            <p>
              MUST 或是 "REQUIRED"、"SHALL"，
              代表这是一个绝对得做的事儿。
              你必须徵询许可来违反一个 MUST。
            </p>
          </td>
        </tr>
        <tr>
          <th valign="top">绝对不要 MUST NOT</th>
          <td>
            <p>
              MUST NOT，或是 "SHALL NOT"，
              代表这是绝对不能做的事儿，
              你必须徵询许可来违反一个 MUST NOT。
            </p>
          </td>
        </tr>
        <tr>
          <th valign="top">推荐 SHOULD</th>
          <td>
            <p>
              SHOULD，或是形容词 "RECOMMENDED"，代表
              在特殊情况下也许有适当的理由可以违反准则的要求，
              但必须了解所有会影响到的事情，在选择另一个主题前审慎衡量。
              你必须徵询谅解来违反一个 SHOULD。
            </p>
          </td>
        </tr>
        <tr>
          <th valign="top">不推荐 SHOULD NOT</th>
          <td>
            <p>
              SHOULD NOT，或是片语 "NOT RECOMMENDED"，代表
              在特殊情况下也许有适当的理由可以违反准则的要求，
              但必须了解所有会影响到的事情，在选择另一个主题前审慎衡量。
              你必须徵询谅解来违反一个 SHOULD NOT。
            </p>
          </td>
        </tr>
        <tr>
          <th valign="top">选择性 MAY</th>
          <td>
            <p>
              MAY，或是形容词 "OPTIONAL"，
              代表某一项完全取决于你。
            </p>
          </td>
        </tr>
      </table>
      <p>
        不像是 RFC，我们在使用上列关键字时，不会将他们都转成大写。
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="许可与谅解">
    <SUMMARY>
      有时候违反某些规则是有用甚至必要的。
      在这些情况里，你必须向适当的人徵询许可或取得谅解。
    </SUMMARY>
    <BODY>
      <p>
        许可来自于项目的负责人。
      </p>
      
      <p>
        在违反准则附近用注解来请求一个谅解，
        而你的代码审查者将授予谅解。
        原先的注解应由你签名，且
        审查者应在审查时往注解添加一个签名许可。
      </p>
      
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="惯例">
    <SUMMARY>
      你必须遵守这些约定。这不是选择性的。
    </SUMMARY>
    <BODY>
      <p>
        某些准则启发自良好的编程普遍原则。
        某些准则启发自 Common Lisp 的技术特性。
        某些准则启发自一个技术理由，
        但在理由消灭后，准则仍被保留了下来。
        某些像是注解及缩排的准则，
        完全是基于惯例，而不是有明显的技术价值。
        无论是什么情况，你必须遵循这些准则，
        以及其他常见但尚未被纳入此文件的准则。
      </p>
      <p>
        你<em>必须</em>遵循惯例。
        它们对于可读性来说非常重要。
        当惯例默认被遵循时，
        违反惯例是某件需要注意的事发生了，并需要留意的信号。
        当惯例被有组织地违反时，
        违反惯例是一个需要被忽略的恼人噪音。
      </p>
      <p>
        常规惯例<em>是</em>一种教化。
        目的使你仿效社群的习俗，

        这样你可以更有效率的与现有成员合作。
        分辨出哪些是启发于技术性、或仅仅是惯例的准则仍然很有用，
        这样你知道何时可以违反惯例来获得好的成效，
        以及何时寻求准则帮助你不掉入陷阱。
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="古老代码">
    <p>
      我们很多代码都是在这些准则存在前所写的。
      当你在平常编程时遇到违反准则的代码时，修补它们。
      你不应在没有警告其他开发者或协调的情况下修补，
      也不应该使合并较大的分支变得比以前困难。
    </p>
  </STYLEPOINT>
  <STYLEPOINT title="未来议题">
    <SUMMARY>
      当前版本的文件没有考虑到许多额外标准化的主题，这留到之后的版本。
    </SUMMARY>
    <BODY>
      <ul>
        <li>
          文件及目录结构
        </li>
        <li>
          包与模组化
        </li>
        <li>
          线程与锁
        </li>
        <li>
          如何添加可配置的组件
        </li>
        <li>
          CLOS 风格：initforms, 槽以及访问器名称，等等。
        </li>
        <li>
          每个类可有的最大槽数的建议。
        </li>
        <li>
          更多良好代码的具体例子：
          <ul>
            <li>
              异常
            </li>
            <li>
              事务（含重试）
            </li>
            <li>
              XML
            </li>
            <li>
              类型
            </li>
            <li>
              封装或抽象
              
            </li>
            <li>
              类别及槽名
            </li>
            <li>
              等等。
            </li>
          </ul>
        </li>
        <li>
          何时（不要）使用条件式编译：
          <ul>
            <li>
              改动产品时
            </li>
            <li>
              条件式调试或终端输出等。
            </li>
            <li>
              “暂时性”注解掉代码块
            </li>
            <li>
              等等。
            </li>
          </ul>
        </li>
      </ul>
    </BODY>
  </STYLEPOINT>
</CATEGORY>
<CATEGORY title="通用准则">
  <STYLEPOINT title="原则">
    <SUMMARY>
      有某些基本原则，需要软件开发团队的每个开发者铭记在心。
      无论何时对于详细的准则感到不适当、疑惑或是自相矛盾时，
      回头看看这些原则来寻求指导：
      <ul>
        <li>
          每一个开发者所写的代码必须让别的开发者容易阅读、理解及改动 —— 即便最初的开发者已经不在了。（这是 “hit by a truck” 理论。）
        </li>
        <li>
          每人的代码看起来要一致。理想上，不应该看到几行代码就认出，
          啊，这个风格是 “Fred 写的代码。”
        </li>
        <li>
          别太聪明 ——
          用最简单可行的办法来完成工作。
        </li>
        <li>
          追求精准。
        </li>
        <li>
          追求简洁。
        </li>
        <li>
          KISS 原则 (Keep It Simple, Stupid)，简单就是美。
        </li>
        <li>
          杀鸡焉用牛刀，用最适当的工具。
        </li>
        <li>
          使用常识。
        </li>
        <li>
          相关代码放在一起。
          将别人需要理解一部分代码所需的画面跳转减到最低。
        </li>
      </ul>
    </SUMMARY>
    <BODY>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="优先级">
    <SUMMARY>
      <p>
        当抉择如何写出一段给定的代码时，依此优先序追求下列性质：
      </p>
      <ul>
        <li>
          客户的易用性。
        </li>
        <li>
          可调试性或可测试性。
        </li>
        <li>     
          可读性或可理解性。
        </li>
        <li>        
          可扩充性或可修改性。
        </li>
        <li>
          （运行期 Lisp 代码的）效率。
        </li>
      </ul>
    </SUMMARY>
    <BODY>
      <p>
        这些准则大部分都是直观的。
      </p>
      <p>
        客户的易用性代表系统满足客户的需求；
        需要处理客户的交易量，正常运作时的需求；等等。
      </p>
      <p>
        针对 Lisp 效率这一点，
        有两个同样复杂的选择，
        选执行较好的那个。
        （通常是构造比较少的那个，
        也就是从堆上配置了较少空间。）
      </p>
      <p>
        给定两个选择，其中一个比另一个复杂，
        选择简单的那个选择，并分析出另一个有更好效能时，
        才重新审视当初的决定。
      </p>
      <p>
        然而，避免过早优化。
        别为了给很少运行的东西提升速度而添加复杂度。
        因为长期来说，鲜少运行的代码快不快不是那么重要。
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="架构">
    <SUMMARY>
      要打造强韧且易维护的代码，
      关系到如何将代码切分成组件，
      这些组件如何沟通，
      改版时改动如何传递，
      而最重要的是
      程序员在改版时如何使这些部分相互沟通。
    </SUMMARY>
    <BODY>
      <p>
        如果你的工作影响到其他的小组，或是可被小组之间重用，
        如添加新组件会影响到其他小组（包括品管及运维），
        或是非本地作业的事情，你必须至少写几段文字，
        在开始写代码前 &#8212; 并获得设计组或其他相关当事人的许可，
        或是在当他们拒绝后，准备好重头开始。
      </p>
      <p>
        如果你不知道或不在乎这些议题，
        问问某些知道或在乎的人。
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="使用函式库">
    <SUMMARY>
      通常最简单的办法是使用一个已存在的函式库。
      或一个还没存在的。
      在还没有的情况，我们鼓励你开发一个这样的函式库，
      但你得未雨稠缪。
    </SUMMARY>
    <BODY>
      <ul>
        <li>
          绝对不要贸然开始写一个新的函式库，
          除非你已查证没有可用的函式库存在，
          而新的函式库完成后可以解决或满足你的需求。
          这是一个违背<a HREF="http://zh.wikipedia.org/zh-cn/%E9%9D%9E%E6%88%91%E6%89%80%E5%89%B5">非我所创</a>症候群的规则，
          这个症候群在 Lisp 黑客圈里特别常见。
        </li>
        <li>
          无论你采用是新的或古老的函式库，你<em>必须</em>获得许可，才能将
          第三方代码并入代码库。
          你必须在对的邮件组讨论这个函式库的用途，
          并将你的代码交给此领域的专业人士审查，
          或是由（如果有的话） Lisp 函式库生态系统的人审查。
          并请准备好说明为什么这个特定的解决方案，
          比其他可用的函式库更好。
        </li>
        <li>
          某些函式库的授权，与你正撰写的软件不兼容，
          则绝对不要将这个函式库认为是可用的。
          当心授权议题，或请教相关人士。
        </li>
      </ul>
      
      <p>
        如果你有一个绝妙的实现技巧，而你的技巧真的如此巧妙，
        则你绝对不要将其放入业务有关的代码；
        但也许可以被开源函式库的代码所用。
        如果你的想法对于任何用户来说不普遍，
        超出了一般的业务用户的认知范围，
        那么这绝对不是聪明或是巧妙，
        在这两个情况里，都不要将技巧纳入代码里。
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="开源代码">
    <SUMMARY>
      <p>
        如果你要写一个通用的函式库，
        或是改动一个存在的开源函式库，
        欢迎你将函式库与项目分开发布，
        并像是用其他的开源库一样导入你的函式库。
      </p>
      
    </SUMMARY>
    <BODY>
      <p>
        用你的判断来分辨通用 vs 业务相关的代码，
        将通用的部份开源出来，
        而业务相关的部份保守为商业机密。
      </p>
      
      <p>
        开源代码有许多好处，能促使第三方参与开发，
        使开发产品特色从用户角度出发，
        并使你诚实面对代码的品质。
        无论你写的是什么代码，你会需要维护他们的，
        并确保代码品质够好，能在产品上线时使用。
        开源正因为如此，不会有什么额外的负担。
        即便是（至少最初是如此）无法直接被第三方使用的代码。
      </p>
      
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="开发过程">
    <SUMMARY>
      开发过程超出了本文件的范围。
      然而开发者至少应记得下列几件小事：
      审查代码，撰写测试，去除警告，运行测试，避免大幅改动。
    </SUMMARY>
    <BODY>
      <p>
      </p>
      <ul>
        <li>
          所有的代码改动必须经过审查。
          你应该期待你的代码会被其他黑客审查，
          而你也会被指派去审查别的黑客的代码。
          审查的部份标准将会是代码需要遵守这份文件所载的编码标准。
        </li>
        <li>
          你必须撰写测试，以及测试新撰写的代码，并记录你所修补的错误 (bug)。
          每一个 API 函数必须有一个单元测试，以及任何先前失败的例子。
          在前述事项做完之前，你的工作都不算完成。
          在评估工作任务时，必须算进撰写测试所花的时间。
        </li>
        <li>
          你的代码编译后必须没有任何编译错误或是警告信息，等等。
          如果需要忽略编译器所抱怨的警告时，
          将这些警告用
          <code>xcvb-driver:with-controlled-compiler-conditions</code> 及
          <code>xcvb-driver:*uninteresting-conditions*</code>
          框架包覆起来（也可以用 <code>asdf-condition-control</code>）。
          要包覆整个项目，或是单一的文件
          （使用 asdf 的 <code>:around-compile</code> hook）。
        </li>
        <li>
          所有的代码应该在一个适当的源代码管理系统检查，
          该系统可以在某种形式上，允许完整重新生成，
          某个已经布署（或可以布署）代码的版本、测试以及执行。
        </li>
        <li>
          你必须在运行测试前先测试单一的组件，
          只有在每个组件通过单元测试时，才可以提交代码。
        </li>
        <li>
          你应该将代码覆盖度纳入你的测试流程。
          如果测试不能涵盖所有新更新的代码，那么测试就是不足够的；
          无论有任何理由，一个测试无法覆盖的代码，
          需要清楚标明，并附上理由。
        </li>
        <li>
          许多人在分之下开发。
          你必须获得许可，再开始大幅度的改动。
          （比如大量的重新缩排）
          这样我们才可事先协调，
          并给予分支充裕的时间来回到主线上。
        </li>
      </ul>
    </BODY>
  </STYLEPOINT>
</CATEGORY>
<CATEGORY title="格式化">
  <STYLEPOINT title="拼写">
    <SUMMARY>
      <p>
        你必须在注解里使用正确的拼写，
        而最重要要拼对的是函数的形参。
      </p>
      <p>
        当数个正确拼写同时存在时（包括美式及英式英语），
        而开发者之间尚未有共识存在时，
        你应该选择较短的拼写。
      </p>
      <p>
        你必须避免使用单词的缩写，除非它是一个相当常用的单词。
        在这个情况下，你必须<em>始终</em>使用<em>同样的</em>缩写。
      </p>
    </SUMMARY>
    <BODY>
      <p>
        如果你不确定的话，查字典吧，
        或是 Google 下来检查拼写。
        或问问当地的专家。
      </p>
      <p>
        下列是如何选择正确拼写的例子：
      </p>
      <ul>
        <li>
          使用 "complimentary" 表示免费饮料或大餐，
          而不是 "complementary"。
        </li>
        <li>
          使用 "existent" 以及 "nonexistent" 而不是 "existant"。
          使用 "existence" 而不是 "existance"。
        </li>
        <li>
          使用 "hierarchy" 而不是 "heirarchy"。
        </li>
        <li>
          使用 "precede" 而不是 "preceed"。
        </li>
        <li>
          使用 "weird" 而不是 "wierd"。
        </li>
      </ul>
      <p>
        下列是如何选择短的拼写的例子：
      </p>
      <ul>
        <li>
          使用 "canceled" 而不是 "cancelled"
        </li>
        <li>
          使用 "queuing" 而不是 "queueing".
        </li>
        <li>
          使用 "signaled" 而不是 "signalled";
        </li>
        <li>
          使用 "traveled" 而不是 "travelled".
        </li>
        <li>
          使用 "aluminum" 而不是 "aluminium"
        </li>
        <li>
          使用 "oriented" 而不是 "orientated"
        </li>
        <li>
          使用 "color" 而不是 "colour"
        </li>
        <li>
          使用 "behavior" 而不是 "behaviour"
        </li>
      </ul>
      <p>
        位工业标准术语或是行话破例，包括了简单的拼写错误。
        比如：
      </p>
      <ul>
        <li>
          在 HTTP 协议的上下文中，使用 "referer" 而不是 "referrer"
        </li>
      </ul>
      
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="行长">
    <SUMMARY>
      你应格式化你的源代码，使单行不超过 100 个字符。
    </SUMMARY>
    <BODY>
      <p>
        有某些行长限制总比没有好。
        古老的文字终端机使用 80 栏，
        但现在允许 100 栏似乎比较好，
        因为好的风格鼓励你使用具有描述性的变量以及函数名称。
      </p>
      
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="缩排">
    <SUMMARY>
      <p>
        像一个配置好的 GNU Emacs 那样缩排你的代码。
      </p>
      <p>
        审慎的缩排会使代码更容易理解。
      </p>
    </SUMMARY>
    <BODY>
      <p>
        一般 GNU Emacs 在缩排 Common Lisp 代码这件工作上表现的非常出色。
        也可以教会 GNU Emacs 如何缩排新定义的形式，
        比如给特定领域语言用的特殊规则。
        每个项目可能含有某些定制缩排的文件；使用它们吧。
      </p>   
      
      <p>
        使用缩排让复杂的函数应用变得容易阅读。
        当一个应用不能放在一行时，
        或是函数接受太多参数，
        考虑在参数之间插入新行，
        让每个参数都是在独立的一行。
        不插入新行在某些方面使得要知道函数接受多少参数或
        参数的从何开始又从何结束变得困难。
      </p>
      <BAD_CODE_SNIPPET>
        ;; 差劲
        (do-something first-argument second-argument (lambda (x)
            (frob x)) fourth-argument last-argument)
      </BAD_CODE_SNIPPET>
      <CODE_SNIPPET>
        ;; 较佳
        (do-something first-argument
                      second-argument
                      #'(lambda (x) (frob x))
                      fourth-argument
                      last-argument)
      </CODE_SNIPPET>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="文件表头">
    <SUMMARY>
      <p>
        应该在每个源文件的最上方，注明维护者及其他重要信息。
      </p>
      <p>
        不应该在源文件里面附上版权声明。
      </p>
    </SUMMARY>
    <BODY>
      <p>
        每一个源文件可以用一个描述文件的单行叙述起头。
      </p>
      <p>
        在刚刚选择性的叙述之后，
        每一个源文件可以包含一个陈述，
        关于最初是谁写了这个代码，
        有哪些主要改动，以及（或是）目前谁是维护者（拥有者）。
        这让黑客找到对的人来询问关于代码的问题、
        或是确定没人可以回答询问，变得更容易。

        然而，如果代码是没人维护的情况，
        且留下的信息也不是非常有助益时；
        以及源代码控制找出信息不是很容易的情况，
        最好略过陈述不写。
      </p>
      <p>
        在选择性的陈述之后，每个文件应该要有一个简短的说明，
        解释这个文件所有的内容。
      </p>
      <p>
        在说明之后，每个文件应该由这个形式开始：
        <code>(in-package :<em>package-name</em>)</code>
      </p>
      <p>
        在 <code>in-package</code> 形式之后，
        接著是任何与文件相关的声明，比如
        <code>(declaim (optimize ...))</code>。
        这些是 asdf <code>:around-compile</code> hook 并没有涵盖到的声明。
      </p>
      <CODE_SNIPPET>
        ;;;; Author: brown (Robert Brown)

        ;;;; Variable length encoding for integers and floating point numbers.

        (in-package #:varint)
        (declaim #.*optimize-default*)
      </CODE_SNIPPET>
      <p>
        你不应该在每个源代码文件附上版权信息。
        单独发布的文件例外。
      </p>
      <p>
        每个项目或函式库有一个单一的文件，详细说明文件的授权。
        没有授权或版权代表这个项目是<a HREF="http://en.wikipedia.org/wiki/Proprietary_software">专有代码</a>。
      </p>
      
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="垂直空间">
    <SUMMARY>
      垂直空间：顶层级别的形式，一个空行。
    </SUMMARY>
    <BODY>
      <p>
        你应该在顶层级别的形式留一个空行，比如函数定义。
        在特殊情况下，空行可以省略，
        简单的、密切相关的、同种类的定义形式，
        比如一组相关的类型声明，或是常量定义。
      </p>
      <CODE_SNIPPET>
        (defconstant +mix32+ #x12b9b0a1 "pi, an arbitrary number")
        (defconstant +mix64+ #x2b992ddfa23249d6 "more digits of pi")

        (defconstant +golden-ratio32+ #x9e3779b9 "the golden ratio")
        (defconstant +golden-ratio64+ #xe08c1d668b756f82 "more digits of the golden ratio")

        (defmacro incf32 (x y)
          "Like INCF, but for integers modulo 2**32"
          `(setf ,x (logand (+ ,x ,y) #xffffffff)))
        (defmacro incf64 (x y)
          "Like INCF, but for integers modulo 2**64"
          `(setf ,x (logand (+ ,x ,y) #xffffffffffffffff)))
      </CODE_SNIPPET>
      <p>
        空行可以把复杂的函数切分成多个部分。
        一般来说，你应该要把大函数切成几个小函数，
        而不是添加垂直空间，让它读起来比较好读。
        如果你不能够切成小函数，你应该要使用 <code>;;</code> 注解，
        说明每个函数的部分各是干嘛的。
      </p>
      <p>
        每个顶层形式应该要少于 61 行，包括注解，但不含文档字串。
        这是用于在 <code>eval-when</code> 里的每个形式，
        而不是 <code>eval-when</code> 本身。
        另外 <code>defpackage</code> 可以超過 61 行，
        因为它可能有长长的列表清单。
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="水平空间">
    <SUMMARY>
      水平空间：括弧之间不要有空格、tab。
    </SUMMARY>
    <BODY>
      <p>
        绝对不要在括号或符号的前面或后面加上额外的空白。
      </p>
      <p>
        绝对不要把右括号单写在一行。
        一组连续的尾随括号必须出现在同一行。
      </p>
      <BAD_CODE_SNIPPET>
        ;; 非常差劲
        ( defun factorial ( limit )
          ( let (( product 1 ))
            ( loop for i from 1 upto limit
                  do (setf product ( * product i ) ) )
            product
          )
        )
      </BAD_CODE_SNIPPET>
      <CODE_SNIPPET>
        ;; 较佳
        (defun factorial (limit)
          (let ((product 1))
            (loop for i from 1 upto limit
                  do (setf product (* product i)))
            product))
      </CODE_SNIPPET>
      <p>
        形式之间应该只用一个空格。
      </p>
      <p>
        你不应该在多行连续的中间，使用空格来垂直排列形式。
        一个例外是当代码不垂直对齐，就看不出你要强调的重要性时。
      </p>
      <BAD_CODE_SNIPPET>
        ;; 差劲
        (let* ((low    1)
               (high   2)
               (sum    (+ (* low low) (* high high))))
          ...)
      </BAD_CODE_SNIPPET>
      <CODE_SNIPPET>
        ;; 较佳
        (let* ((low 1)
               (high 2)
               (sum (+ (* low low) (* high high))))
          ...))
      </CODE_SNIPPET>
      <p>
        你必须排列嵌套型时，如果他们超过一行的话。
        You must align nested forms if they occur across more than one line.
      </p>
      <BAD_CODE_SNIPPET>
        ;; 差劲
        (defun munge (a b c)
        (* (+ a b)
        c))
      </BAD_CODE_SNIPPET>
      <CODE_SNIPPET>
        ;; 较佳
        (defun munge (a b c)
          (* (+ a b)
             c))
      </CODE_SNIPPET>
      <p>
        惯例是一个绑定形式的主体，在第一行之后缩排两格。
        任何在主体之前的绑定数据，通常缩排四格。
        函数调用的参数与第一个参数对齐；
        如果第一个参数自成一行，
        则与函数名称对齐。
      </p>
      <CODE_SNIPPET>
        (multiple-value-bind (a b c d)
            (function-returning-four-values x y)
          (declare (ignore c))
          (something-using a)
          (also-using b d))
      </CODE_SNIPPET>
      <p>
        一个可有单独括号的例外献给一个，
        数个定义之间的<code>eval-when</code> 形式；
        在这个情况下，在闭括号附上一个注解 <code>; eval-when</code>。
      </p>
      <p>
        你必须设置编辑器，让你在编辑文件时，避免插入 tab 字符。
        当编辑器不同意一个 Tab 是由几个空格代表时，Tab 会使你困惑。
        在 Emacs，输入 <code>(setq-default indent-tabs-mode nil)</code>。
      </p>
    </BODY>
  </STYLEPOINT>
</CATEGORY>
<CATEGORY title="文档">
  <STYLEPOINT title="钜细靡遗">
    <SUMMARY>
      你应该给所有可视函数使用文档字串，
      来解释如何使用你的代码。
    </SUMMARY>
    <BODY>
      <p>
        除非某段代码完全一目了然，不然就上一个文档字串（别名 docstring）。
      </p>
      <p>
        文档字串生来就是给使用代码的程序员读的。
        他们可以从函数、类型、类别、变量以及宏取出，
        并通过编程工具，如 IDE 来显示。
        或是通过在 REPL 下查询，如 <code>(describe 'foo)</code>；
        放在网上的文档或其他参考著作也可以在文档字串的基础上来创建。
        因此，文档字串是给你的 API 撰写文档的完美地点。
        应该描述如何使用代码（包括需要避开的陷阱），
        而不是代码是如何工作的（以及之后所需的工作），
        这两个是你该放在注解的东西。
      </p>
      <p>
        当定义一个顶层及别的函数、类型、类别、变量以及宏时，提供一个文档字串。
        一般则是在程序语言允许加入文档的地方，添加文档字串。
      </p>
      <p>
        关于函数，docstring 应该要描述函数的合约：
        这个函数干什么，
        这个函数的参数表示什么，
        这个函数所返回的值，
        这个函数可捕捉的状况。
        应该在适当的抽象层级上来表达，解释意图，而不仅是解释语法。
        在文档字串里，将 Lisp 符号的名字转为大写，比如函数参数。
        打个比方，"The value of LENGTH should be an integer."
      </p>
      <CODE_SNIPPET>
        (defun small-prime-number-p (n)
          "Return T if N, an integer, is a prime number. Otherwise, return NIL."
          (cond ((or (&lt; n 2))
                 nil)
                ((= n 2)
                 t)
                ((divisorp 2 n)
                 nil)
                (t
                 (loop for i from 3 upto (sqrt n) by 2
                       never (divisorp i n)))))
      </CODE_SNIPPET>
      <CODE_SNIPPET>
        (defgeneric table-clear (table)
          (:documentation
            "Like clrhash, empties the TABLE of all
            associations, and returns the table itself."))
      </CODE_SNIPPET>
      <p>
        一个长的 docstring 通常用一句话的总结开始是有用的，
        接著才是 docstring 的主要内容。
      </p>
      <p>
        当一个类型的名称被使用时，
        符号可以用反引号及单引号包围，
        反引号在前，单引号在后。
        Emacs 会将类型高亮，而高亮作为读取器的线索，
        <kbd>M-.</kbd> 会跳转到符号的定义。
      </p>
      <CODE_SNIPPET>
        (defun bag-tag-expected-itinerary (bag-tag)
          "Return a list of `legacy-pnr-pax-segment' objects representing
          the expected itinerary of the `bag-tag' object, BAG-TAG."
          ...)
      </CODE_SNIPPET>
      <p>
        当特化影响了方法的行为，
        超出通用函数的 docstring 所描述的内容时，
        应该给通用函数的每一个方法各自撰写文档。
      </p>
      <p>
        当你修补了一个错误，
        思考看看修补后的代码是否正确，还是是错误的；
        如果不对的话，你必须添加一个注解，
        从修补错误的观点来解释代码。
        如果可以的话，添加错误序号，也是推荐的。
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="分号注解">
    <SUMMARY>
      你必须使用正确数量的分号来写注解。
    </SUMMARY>
    <BODY>
      <p>
        注解是给未来维护代码的人的说明。
        即便你是唯一能够看与触摸代码的人，
        即便你长生不老或是永远不离职，
        或是离职之后根本不管的人（并在这种万一的情况下使你的代码自行毁灭），
        你可能会发现给代码写注解是有帮助的。
        当然啦，在几个礼拜、月、年之后，回头看看代码时，
        你会发现当初写这个代码的人，完全与你不是同一个人，
        则你会感激当初自己有留下注解。
      </p>
      <p>
        你必须给任何复杂的代码留注解，
        这样一来下个开发者才可以了解情况。
        （又来了，“hit by a truck” 理论。）
      </p>
      <p>
        注解也可以作为指引阅读代码的人的一种方式，
        这样他们才知道这里有什么。
      </p>
      <ul>
        <li>
          文件表头及源文件里大段代码的重要注解，
          注解应该使用四个分号。
        </li>
        <li>
          一个顶层级别的形式或是小组的顶层级别形式，
          注解应该使用三个分号。
        </li>
        <li>
          在一个顶层级别的形式里，
          如果注解出现在行之间，
          注解应该使用两个分号。
        </li>
        <li>
          如果是一个括号的备注且出现在行的最后，
          注解应该使用一个分号。
          你应该使用空格来分离注解与引用的代码，
          使得注解脱颖而出。
          你应该试著垂直排列相关的行尾注解。
        </li>
      </ul>
      <CODE_SNIPPET>
        ;;;; project-euler.lisp
        ;;;; File-level comments or comments for large sections of code.

        ;;; Problems are described in more detail here:  http://projecteuler.net/

        ;;; Divisibility
        ;;; Comments that describe a group of definitions.

        (defun divisorp (d n)
          (zerop (mod n d)))

        (defun proper-divisors (n)
          ...)

        (defun divisors (n)
          (cons n (proper-divisors n)))

        ;;; Prime numbers

        (defun small-prime-number-p (n)
          (cond ((or (&lt; n 2))
                 nil)
                ((= n 2)   ; parenthetical remark here
                 t)        ; continuation of the remark
                ((divisorp 2 n)
                 nil)  ; different remark
                ;; Comment that applies to a section of code.
                (t
                 (loop for i from 3 upto (sqrt n) by 2
                       never (divisorp i n)))))
      </CODE_SNIPPET>
      <p>
        在分号与注解文字之间，应该留一个空格。       
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="标点与文法">
    <SUMMARY>
      你应该使用正确的标点符号来写文档。
    </SUMMARY>
    <BODY>
      <p>
        当一个注解是完整的句子时，你应该将第一个字大写，
        并用一个句号结束注解。
        普遍来说，你应该使用正确的标点符号。
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="小心注意">
    <SUMMARY>
      需要特别留意的注解，
      你必须遵循使用 <code>---</code> 前缀的惯例，
      包括了晦涩的编码技巧、TODO 事项、问题、损坏及危险。
    </SUMMARY>
    <BODY>
      <ul>
        <li>
          用 <code>;--- </code> 写一个警告性的注解，
          比如解释这段涉及的代码为什么特别棘手、微妙，或不是这么直观的。
        </li>
        <li>
          用 <code>;---??? </code> 写一个严重问题，
          需要尽快通过修补代码或是文档来解决。
        </li>
        <li>
          用 <code>;---!!! </code> 来识别坏掉的代码，
          但出于某些原因，你不能在这个时候修复它。
          你最好不要在新的代码太常使用这个。
        </li>
        <li>
          用 <code>;---*** </code> 来识别重大危险，
          举例来说，重要的功能不能用了，
          或是重要的设计问题仍未解决。
          在代码上线之前，
          将任何需要解决的事情标记起来。
        </li>
      </ul>
      <p>
        你必须在任何"需要进一步关切"的注解签名并加注日期，
        但单纯的警告性注解不用。
      </p>
      <p>
        上面这个策略确保了用 grep 查找 <code>;---</code> 时，
        永远会给出所有需要谨慎处理的注解，
        并且每件事都知道该找谁商量。
      </p>
      <p>
        需要用到 <code>;---</code> 的注解，
        仅在第一行使用 <code>;---</code>。
        其他行应使用空格来垂直对齐。
        这样一来，grep 也会给出问题的数目。
      </p>
      <p>
        在注解前缀后面应插入一个空格。
      </p>
      <p>
        你也可以在多重分号注解里面使用这些前缀。
      </p>
      <p>
        某些人喜欢使用像是 <code>FIXME</code> 或是 <code>TODO</code> 这样的单词。
        你可以使用它们，但它们前面必须有 <code>---</code>。
      </p>
      <p>
        当已经知道代码尚未完成，
        而你想要指出有哪些工作还需要完成时，使用 TODO 注解，
      </p>
      <p>
        由 TODO（全大写）、跟著是括号内的邮箱或其他标识符，
        跟著一个冒号，一个空格，以及需要的说明。
        开始的注解，

        TODO 注解的格式，由 TODO （全大写）开始，接著是括号，
        括号内是你的邮箱或是其他人，再来是一个冒号跟空格，
        以及额外需要完成或想要完成的工作说明。
        包含在此注解内的用户名，是理解这个缺陷的那个人。
        
        一个 TODO 注解不保证要修补问题。
      </p>
      <p>
        当给注解签名时，
        应该使用你的用户名（针对公司内部代码），
        或是完整 email 地址（针对公司外部可见代码），
        而不只是名字的首字母缩写。
      </p>
      <CODE_SNIPPET>
        ;;--- TODO(george@gmail.com): Refactor to provide a better API.
      </CODE_SNIPPET>
      <p>
        在一个 TODO 注解理，具体指出时间或是软件版本：
      </p>
      <CODE_SNIPPET>
        ;;--- TODO(brown): Remove this code after release 1.7 or before November, 2012.
      </CODE_SNIPPET>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="特定领域语言">
    <SUMMARY>
      你应该给 DSL 及任何在 DSL 里的简短程序写文档。
    </SUMMARY>
    <BODY>
      <p>
        你应该设计同行容易阅读及理解的特定领域语言。
      </p>
      <p>
        你必须正确地给你的特定领域语言写文档。
      </p>
      <p>
        有的时候，你的特定领域语言
        在这个情况里，如果每个程序从上下文中不是很直观的话，
        用文档说明每个程序干了什么是很重要的。
      </p>
      <p>
        值得注意的是，当你使用正则表达式时
        （比如使用 <code>CL-PPCRE</code> 包），
        你必须始终留一条注解（通常在前一行加两个分号的注解），
        （最起码）要解释正则表达式做了什么，或是使用他的目的。
        注解不需要解释所有语法的细节，
        但应该让别人不需要解析正则表达式，
        就知道你代码的逻辑是什么。
      </p>
    </BODY>
  </STYLEPOINT>
</CATEGORY>
<CATEGORY title="命名">
  <STYLEPOINT title="符号准则">
    <SUMMARY>
      使用小写。
      不要缩写。
      遵循标点符号的惯例。
    </SUMMARY>
    <BODY>
      <p>
        所有的符号使用小写。
        一致地使用小写，可读性更高之外，也让查找符号名变得更容易。
      </p>
      <p>
        注意 Common Lisp 会自动转换大小写，
        而对一个符号调用 <code>symbol-name</code> 会返回大写。
        由于这个转换大小写的特色，当你试著要分辨符号的大小写时，
        最终只会让你陷入困惑。
        但使用逃脱字符也是可以强迫符号成为小写的，
        不过你不应该使用这个功能，除非你需要与第三方软件协同操作。
      </p>
      <p>
        在一个符号的单词之间放连字符。
        如果你不能很简单的说出标识符的名字，
        那符号大概命名的很差劲。
      </p>
      <p>
        连字符必须用 <code>"-"</code>，
        不要用 <code>"/"</code> 或是 <code>"."</code>。
        除非你有一个无懈可击的理由，
        以及你的提议取得了来自其他黑客的许可。
      </p>
      <p>
        普遍来说，你不应该使用单词缩写。
        必须避免使用单词缩写，除非它是一个非常常用的单词，
        在这个情况下，你必须<em>一致地</em>使用<em>同样的</em>缩写。
        
        缩写可以节制地使用，来避免过长的符号名；
        当有一个非常长的名字时，100 栏的限制很快就用完了。
        你必须特别在导出名字时，避免不一致的缩写。
        针对限制性作用域的词法变量，缩写是可以接受的。
      </p>
      <p>
      </p>
      <BAD_CODE_SNIPPET>
        ;; 差劲
        (defvar *default-username* "Ann")
        (defvar *max-widget-cnt* 200)
      </BAD_CODE_SNIPPET>
      <CODE_SNIPPET>
        ;; 较佳
        (defvar *default-user-name* "Ann")
        (defvar *maximum-widget-count* 200)
      </CODE_SNIPPET>
      <p>
        Common Lisp 在符号内使用标点符号是有惯例的。
        你不应该在这些惯例之外，在符号内使用标点符号。
      </p>
      <p>
        除非变量的作用域非常小，不要使用过短的名字，
        像是：
        <code>i</code> 以及 <code>zq</code>.
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="表明目的，而非内容">
    <SUMMARY>
      将变量用目的命名，而不是变量的内容。
    </SUMMARY>
    <BODY>
      <p>
        应该根据变量所意涵的概念命名，
        而不是根据概念在机器底层是怎么表示的来命名。
      </p>
      <p>
        因此，你应该避免嵌入数据结构或结合类型名称，
        比如将 <code>list</code>, <code>array</code>，或是
        <code>hash-table</code> 嵌入变量名，
        除非你正在写一个通用的演算法，适用于任何的列表、数组、哈希表，等等。
        在这个情况下，变量名有 <code>list</code> 或 <code>array</code>
        是完全没问题的。
      </p>
      <p>
        当然啦，无论何时你有创造新种对象的目的时，
        你应该使用 <code>DEFCLASS</code> 或 <code>DEFTYPE</code>，
        来引入新的抽象数据类型，操作这些对象的函数，
        可以通用地使用反映出抽象类型的名称。
      </p>
      <p>
        举例来说，如果一个变量的值，
        总是一个 row（或是 <code>NIL</code>），
        叫它 <code> row </code> 或 <code>first-row</code> 是很好的，
        或者是其他相似的名字。
        <code>row</code> 被 <code>DEFTYPE</code> 
        定义成 <code>STRING</code> 是没问题的。
        严格来说，因为你将细节抽象起来了，
        剩下的亮点是，它是一个 row。
        在这个上下文里，不应该将变量取名为 <code>STRING</code>，
        除非底层函数明确地操作 row 的内部结构，提供与 STRING 类似的抽象。
      </p>
      <p>
        保持一致。
        如果变量在一个函数里命名成 <code>row</code>，
        且它的值被传给第二个函数，
        则将其称为 <code>row</code> 而不是 <code>value</code>。
        （这是一个实际情况）
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="全局变量与常量">
    <SUMMARY>
      根据惯例来命名全局变量。
    </SUMMARY>
    <BODY>
      <p>
        全局常量名应由加号开始，并以加号结束。
      </p>
      <p>
        全局变量名应由星号开始，并以星号结束
        （在这个上下文里，星号又称为耳套）。
      </p>
      <p>
        在某些项目里，参数在普通情况下，通常不会被绑定或改动
        （但也许某些实验或例外情况会），应用一个钱号开始（但非钱号结束）。
        如果这样的惯例在你的项目里存在的话，
        你应该一致地遵守。
        否则，应该避免这样子命名变量。
      </p>
      <p>
        Common Lisp 没有全局词法变量，
        所以命名惯例是确保全局变量会被动态绑定，
        以及不会与局部变量名称重复。
        要捏造一个全局词法变量也是有可能的，
        只要有 <code>DEFINE-SYMBOL-MACRO</code> 
        以及用不同的方式命名全局变量。
        不应该使用这个技巧，除非你先发布一个函式库将它抽象起来。
      </p>
      <CODE_SNIPPET>
        (defconstant +hash-results+ #xbd49d10d10cbee50)

        (defvar *maximum-search-depth* 100)
      </CODE_SNIPPET>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="判断式名称">
    <SUMMARY>
      判断式函数的名字以 <code>"P"</code> 结尾。
    </SUMMARY>
    <BODY>
      <p>
        你应该将返回布尔值的函数，
        结尾以 <code>"P"</code> 或 <code>"-P"</code> 命名，
        来表示他们是判断式。
        一般来说，你应该使用，
        函数名是一个单词时，使用 <code>"P"</code>；
        超过一个单词时，使用 <code>"-P"</code>。
      </p>
      <p>
        这个惯例的理由在
        <a href="http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node69.html">the CLtL2 chapter on predicates</a> 给出。
      </p>
      <p>
        为了要统一，你应该遵循上面的惯例，
        而不是下面其中一个替代方案。
      </p>
      <p>
        一个替代规则是，在某些已存在的包，
        总是使用 <code>"-P"</code>。

        另一个替代规则是，在某些已存在的包，
        总是使用 <code>"?"</code>。

        当你开发一个包时，你必须要与其它的包保持一致。
        当你开始一个新包时，在没有非常充分记录你的理由之前，
        你应该不要使用这些替代规则，
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="忽略函式库前缀">
    <SUMMARY>
      符号名不应该纳入一个函式库或包的前缀。
    </SUMMARY>
    <BODY>
      <p>
        当在包里命名（内部或外部）符号时，
        你布应该将包的名称作为前缀含在符号里。
        这样命名符号，让访问这个包的人，
        必须使用包前缀来修饰，这样是很尴尬的。
        （一次是包的前缀、另一次是符号名的前缀）。
      </p>
      <BAD_CODE_SNIPPET>
        ;; 差劲
        (in-package #:varint)
        (defun varint-length64 () ... )

        (in-package #:client-code)
        (defconst +padding+ (varint:varint-length64 +end-token+))
      </BAD_CODE_SNIPPET>
      <CODE_SNIPPET>
        ;; 较佳
        (in-package #:varint)
        (defun length64 () ... )

        (in-package #:client-code)
        (defconst +padding+ (varint:length64 +end-token+))
      </CODE_SNIPPET>
      <p>
        上述规则的一个例外会是给变量名加入前缀，
        不然就会与使用当前这个包的人起冲突的情况。
        举例来说，<code>ASDF</code> 导出一个变量叫做 <code>*ASDF-VERBOSE*</code>，
        这个变量只受唠叨的 ASDF 控制，而不是整个 Lisp 程序。
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="包">
    <SUMMARY>
      适当地使用包。
    </SUMMARY>
    <BODY>
      <p>
        Lisp 的包用来划分命名空间。
        通常每个系统有独立的命名空间。
        一个包有一组导出的符号，
        目的就是给包外部的人用的，
        允许其它的模组使用模组内的实用函数。
      </p>
      <p>
        包的内部符号应该永远不可以被其它的包引用。
        也就是说，你应该永远不需要使用两个冒号
        <code>::</code> 来建构符号
        （比如：<code>QUAKE::HIDDEN-FUNCTION</code>）。
        如果需要使用两个冒号来实际上线的代码，
        那么一定有什么出错了，并需要人来修补。
      </p>
      <p>
        有一个例外是，
        单元测试可使用被测包的内部符号。
        当你重构时，小心那些被包的单元测试所使用的内部符号。
      </p>
      <p>
        <code>::</code> 用来建构非常临时的窍门 (hack)，
        或是在 REPL 使用也是很有用的。
        但若是符号真是外部可见的包定义中的一部分，
        导出它。
      </p>
      <p>
        你可能发现某些内部符号所代表的概念，你通常会想要抽象起来，
        藏在表面之下，但有时又需要让外部扩展的人使用。
        针对前一个理由，你不想导出它们，
        针对后一个理由，你需要导出他们。
        解决办法是有两个不同的包，
        一个给正常用户使用，另一个给实现本身及扩展者使用。
      </p>
      <p>
        包有两种：
      </p>
      <ul>
        <li>
          一种是被纳入其它包的 <code>:use</code> 规格说明。
          如果甲包使用乙包，则乙包的外部符号可以在甲包内被引用，
          而无需使用包的前缀。
          我们主要在底层模组使用这种包，来提供广用的实用函数。
        </li>
        <li>
          一种是不打算被使用。
          要引用乙包提供的一个实用函数时，
          甲包的代码必须使用一个显式的包前缀，
          比如 <code>乙:DO-THIS</code>。
        </li>
      </ul>
      <p>
        如果你添加了一个新的包，它应该总是第二种的，
        除非你有一个特殊理由并获得许可。
        包内的函数名会根据包的用途变化。
        举例来说，如果你有一个叫做 <code>FIFO</code> 的抽象，
        且是属于第一种类的包。
        则你会有像是 <code>FIFO-ADD-TO</code> 以及 <code>FIFO-CLEAR-ALL</code>
        这样名称的函数名。
        如果你的包是第二种类的用途，
        则会有像是 <code>FIFO:ADD-TO</code> 以及 <code>FIFO:CLEAR-ALL</code>
        这样名称的函数名，因为调用者会
        <code>FIFO:ADD-TO</code> and <code>FIFO:CLEAR-ALL</code> 这么用。
        （<code>FIFO:FIFO-CLEAR-ALL</code> 既冗赘又丑陋。）
      </p>
      <p>
        另一件关于包的好事是，
        符号名不会与其它包的名称起冲突，
        除非你的包"自己"起冲突。
        所以你得小心 Lisp 实现自带的名称（因为你总是会用），
        以及其它你所使用的包的名称。
        但你可以自由取任何名字，即便是短的名字，
        而不需要担心别人使用了同样的名称。
        包使你与别人隔离开了。
      </p>
      <p>
        你的包绝对不要遮蔽(重定义）属于 Common Lisp 语言部分的符号。
        某些时候例外，但理由必须要非常充分，这种情况相当稀少：
      </p>
      <ul>
        <li>
          如果你显式地用一个更安全或更有特色的版本，
          替换 Common Lisp 内置的符号。
        </li>
        <li>
          如果你定义一个不打算给人用的包，
          并有一个好的理由，支持你导出与 Common Lisp 抵触的符号，
          如 <code>log:error</code> 以及 <code>log:warn</code> 等等。
        </li>
      </ul>
    </BODY>
  </STYLEPOINT>
</CATEGORY>
<CATEGORY title="语言使用准则">
  <STYLEPOINT title="以函数式风格为主">
    <SUMMARY>
      不是必要的情况下，避免使用副作用。
    </SUMMARY>
    <BODY>
      <p>
        Lisp 的最佳用法是"以函数式风格为主"。
      </p>
      <p>
        避免改动局部变量，重新绑定试试。
      </p>
      <p>
        避免创建对象并给他们的槽赋值。
        最好在初始化的时候将槽设置好。
      </p>
      <p>
        让类别越坚固越好，也就是说，尽可能避免给槽用赋值函数。
      </p>
      <p>
        以函数是风格为主使得撰写线程安全的并发代码变得非常简单。
        也使得测试代码变容易了。
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="递归">
    <SUMMARY>
      你应该偏好迭代胜于递归。
    </SUMMARY>
    <BODY>
      <p>
        Common Lisp 系统不要求每个实现实作不会泄漏栈内存的尾递归 &#8212;
        也称为正规尾调用 (PTC)、尾调用消除(TCE) 或尾调用优化 (TCO)。
        这表示由尾调用所产生的无穷递归很快就把栈吃光光了，
        阻碍了函数式编程。
        最严格的实现（包括了 SBCL 与 CCL) 还是有实作正规尾调用，
        但有如下限制：
      </p>
      <ul>
        <li>
          <code>(DECLARE (OPTIMIZE ...))</code> 的设置必须
          <code>SPEED</code> 够高且
          <code>DEBUG</code> 不能太高，
          这里的够高与不能太高，每个编译器的数值都不同。
          （举例来说，在 SBCL，
          你应该避免 <code>(SPEED 0)</code> 以及 <code>(DEBUG 3)</code> 
          来实现正规尾调用。）
        </li>
        <li>
          应该避免在调用时使用动态绑定（即使某些 Scheme 编译器能够
          正确处理这样的动态绑定，根据 Scheme 的说法是叫做 parameters。）
        </li>
      </ul>
      <p>
        为了兼容所有的编译器及优化设置，以及避免调试时栈溢出发生，
        你应该偏好迭代或是内置的映射函数，胜于依赖正规尾调用。
      </p>
      <p>
        如果你真的得用正规尾调用的话，
        你必须明显记录起来，并实验编译器的优化参数，
        确保你使用了正确的优化设置。
        想要有可移植到任何地方的代码，
        你可以使用一个迭代地调用续延传递函数的循环 (<a HREF="http://en.wikipedia.org/wiki/Trampoline_(computing)#High_Level_Programming">trampolines</a>)。
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="特殊变量">
    <SUMMARY>
      节制使用特殊变量。
    </SUMMARY>
    <BODY>
      <p>
        应该节制使用 Lisp 的"特殊" （动态绑定）变量作为函数的隐式参数，
        并且只在不会吓到读代码的人的前提下使用，
        以及有显著好处的情况下使用。
      </p>
      <p>
        每个特殊变量会建立状态。
        当试著要了解代码在干嘛或代码怎么实现的时候，
        开发者需要绞尽脑汁地追踪所有相关变量的状态；
        需要撰写测试并运行所有相关的可能性；
        要将某个行为隔离时，必须考虑到所有相关的局部变量，
        包括那些没有直接使用模组的局部变量。
        他们可能隐藏了珍贵的信息，可以通过印出回溯来得知。
        特殊变量不仅给每个新创建的变量带来负担，
        特殊变量数目上升时，也使变量之间的互动变得更复杂。
        收支必须平衡啊。
      </p>
      <p>
        需要注意的是，虽然 Lisp 的特殊变量，
        与 BASIC 或 C 概念上的全局变量不同。
        特殊变量可以动态地绑定到一个局部值，
        在每个用户需要互相往来时，
        比一般仅存放全局数值的内存空间（全局变量）来得强大。
      </p>
      <p>
        特殊变量好的使用时机是，
        当 "the current" 可以很自然的用作前缀时，
        像是 "the current database connection" 或是
        "the current business data source" 。
        在其它代码仍有用到特殊变量的情况下，特殊变量是单例，
        并通常作为显式参数传递，
        但不对充满疑惑的源代码提高可读性或是可维护性。
      </p>
      <p>
        特殊变量可以使撰写出能够重构的代码更简单。
        如果你有一个处理请求链，有著数个操作在"当前"请求的层级，
        将请求对象显式地传给每个函数，
        需要在链中的每个函数都有一个请求参数。
        将代码重构成新的函数，通常需要这些函数也有这个参数，
        也会把用模版写成的代码弄的杂乱不堪。
      </p>
      <p>
        应该将特殊变量想成是每个线程只有一个的变量。
        默认情况下，你应该让一个特殊变量不具有任何的顶层绑定，
        而每个需要用到特殊变量的线程控制，应该要显式地绑定。
        这代表著任何误用特殊变量的情况，
        会引起一个 "unbound variable" 错误，
        而每个线程只会看到变量自己的值。
        有默认全局数值的变量通常是在线程创建时绑定。
        你应该使用适合的架构来自动妥善地宣告这样的变量。
      </p>     
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="赋值">
    <SUMMARY>
      使用赋值形式要一致。
    </SUMMARY>
    <BODY>
      <p>
        There are several styles for dealing with assignment and side-effects;
        whichever a given package is using,
        keep using the same consistently when hacking said package.
        Pick a style that makes sense when starting a new package.
      </p>
      <p>
        Regarding multiple assignment in a same form, there are two schools:
        the first style groups as many assignments as possible into a single
        <code>SETF</code> or <code>PSETF</code> form
        thus minimizing the number of forms with side-effects;
        the second style splits assignments into as many individual
        <code>SETF</code> (or <code>SETQ</code>, see below) forms as possible,
        to maximize the chances of locating forms that modify a kind of place
        by grepping for <code>(setf (foo ...</code>.
        A grep pattern must actually contain as many place-modifying forms
        as you may use in your programs, which may make this rationale either
        convincing or moot depending on the rest of the style of your code.
        You should follow the convention used in the package you are hacking.
        We recommend the first convention for new packages.
      </p>
      <p>
        Regarding <code>SETF</code> and <code>SETQ</code>,
        there are two schools:
        this first regards <code>SETQ</code>
        as an archaic implementation detail,
        and avoids it entirely in favor of <code>SETF</code>;
        the second regards <code>SETF</code>
        as an additional layer of complexity,
        and avoids it in favor of <code>SETQ</code> whenever possible
        (i.e. whenever the assigned place is a variable or symbol-macro).
        You should follow the convention used in the package you are hacking.
        We recommend the first convention for new packages.
      </p>
      <p>
        In the spirit of a mostly pure functional style,
        which makes testing and maintenance easier,
        we invite you to consider how to do things with the fewest assignments required.
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="断言与条件式">
    <SUMMARY>
      你必须正确地使用断言与条件式。
    </SUMMARY>
    <BODY>
      <ul>
        <li>
          <code>ASSERT</code> 应该只在侦测内部错误时使用。
          程序应该 <code>ASSERT</code> 那些不变的值，
          一旦 <code>ASSERT</code> 失败就表示软件哪里坏掉了。
          不正确的输入应该在运行期妥善地处理，
          并绝对不要产生违反断言的状况。
          观赏断言失败的观众是开发者。
          不要在 <code>ASSERT</code> 里使用 data-form 以及 argument-form
          来指定要捕捉什么条件。
          出于调试的目的，使用他们来印出信息没问题的
          （而这仅用来调试，不会有国际化的问题）。
        </li>
        <li>
          <code>CHECK-TYPE</code>,
          <code>ETYPECASE</code> 也是断言的形式。
          当某一个失败时，就找到了一个错误。
          针对函数的输入，
          应该偏好使用 <code>CHECK-TYPE</code> 胜于 (DECLARE (TYPE ...))。
        </li>
        <li>
          代码应该要可以自由地使用断言及类型检查。
          及早发现错误，及早修补！
          只有在性能非常要求的地方，还有内部的辅助函数，
          应该避开显式的断言及类型检查。
        </li>
        <li>
          不合法的输入，像是读取的文件与预期格式不符，
          不应视为违反断言。总是检查输入，确保是合法的，
          并在不合法的情况下，用适当的行动回应，
          像是捕捉一个实际错误。
        </li>
        <li>
          <code>ERROR</code> 应用来侦测用户数据、请求、许可的问题等，
          或是回报不寻常的输出给调用者。
        </li>
        <li>
          <code>ERROR</code> 应该始终被一个显式的条件类型调用；
          应当永远不要仅用一个字串来调用。
          这样才可能国际化。
        </li>
        <li>
          通过捕捉状况，回报不寻常输出的函数，应当在合约里明显说明；
          当函数捕捉了一个状况，而状况不是在合约规范里时，
          这是一个错误。
          合约应清楚说明有状况类别。
          函数则可以捕捉任何与那些状况同类的状况。
          也就是说，记录在合约中类别的子类，
          捕捉这些子类的实例是没问题的。
        </li>
        <li>
          复杂的错误检查可能需要使用 <code>ERROR</code> 
          而不是 <code>ASSERT</code>。
          
        </li>
        <li>
          在撰写一个服务器时，绝对不要调用 <code>WARN</code>。
          而是应该使用合适的记录框架。
          
        </li>
        <li>
          代码绝对不要调用 <code>SIGNAL</code>。          
          而是使用 <code>ERROR</code> 或 <code>ASSERT</code>.
        </li>
        <li>
          代码不应该使用 <code>THROW</code> 以及 <code>CATCH</code>；
          而是使用 <code>restart</code> 工具。
        </li>
        <li>
          代码不应该全盘处理所有的状况，
          比如说，类别 <code>T</code> ，或是使用 <code>IGNORE-ERRORS</code>。
          而是让未知的状况交给万能救星 Lisp 来处理。
          <!--- standard ultimate handler = 万能救星 Lisp -->    
        </li>
        <li>
          有少数场合，处理所有的状况是可以的，但这情况很少。
          问题在于处理所有的状况，可能隐蔽了程序的错误。
          如果你真的需要处理"所有的状况"，
          你必须只处理 <code>ERROR</code>，绝对不要处理 <code>T</code>
          以及绝对不要处理 <code>SERIOUS-CONDITION</code>。
          （这是需要注意的，因为在 CCL 里，进程会不会终止，
          取决于有没有捕捉到 <code>process-reset</code>，
          并会交由 CCL 的处理器来处理，所以我们绝对不要插手。）
        </li>
        <li>

          <code>(error (make-condition 'foo-error ...))</code>
          等价于 <code>(error 'foo-error ...)</code> &#8212;
          代码必须使用简洁的形式。
        </li>
        <li> <!--- NTR, Need to Refactor -->
          在清除形式的 <code>UNWIND-PROTECT</code> 里，不应该捕捉状况
          （除非他们总是在这形式里处理）。
          不然就从清除形式跳出，
          比如 <code>INVOKE-RESTART</code>。
        </li>
        <li>
          不要通过重新捕捉来结束一个状况。
          如果你这么干，而刚刚的状况没有处理，
          则栈的追踪会停在重新捕捉那点，
          将之前的隐藏起来。
          而隐藏起来的那部分，才是我们所关心的！
          <BAD_CODE_SNIPPET>
            ;; 差劲
            (handler-case
              (catch 'ticket-at
                (etd-process-blocks))
              (error (c)
                (reset-parser-values)
                  (error c)))
          </BAD_CODE_SNIPPET>
          <CODE_SNIPPET>
            ;; 较佳
            (unwind-protect
              (catch 'ticket-at
                (etd-process-blocks))
              (reset-parser-values))
          </CODE_SNIPPET>
        </li>
      </ul>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="类型检查">
    <SUMMARY>
      如果你知道某个东西的类型，
      为了要启用合理的编译期与运行期检查，你应该明确指明它的类型。
    </SUMMARY>
    <BODY>     
      <p>
        如果你的函数正使用特殊变量作为隐式参数，
        帮特殊变量放一个 <code>CHECK-TYPE</code> 是很好的，
        这有两个理由：
        第一，给阅读代码的人留下线索，这个变量是隐式地作为参数；
        第二，帮助找到错误。
      </p>
      <p>
        使用 <code>(declare (type ...))</code> 
        是万不得已的手段，Scott McKay 如是说：
      </p>
      <blockquote>
        <p>
          事实上，<code>(declare (type ...))</code> 根据编译器速度、
          安全性、等等设定的不同，做出不一样的事情。
          在某些编译器，速度比安全重要时，<code>(declare (type ...))</code> 
          会告诉编译器"请假设变量是这些类型"而不做任何类型检查。
          也就是说，如果某个变量的值是 <code>1432</code>，
          而你却说它的类型是 <code>string</code>，
          编译器听信于你，并将它当成一个字串来使用。
        </p>
        <p>
          道德底线：不要使用 <code>(declare (type ...))</code>
          来声明任何 API 函数的合约，这样做是不对的。
          当然在"辅助函数"可以使用，但不是 API 函数。
        </p>
      </blockquote>
      <p>
        当然你应该在内部底层函数里，使用适当的声明。
        这些声明被用来优化代码。当你这么做的时候，
        看看我们关于<a href="#危险操作">危险操作</a>的建议。
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="Common Lisp 对象系统">
    <SUMMARY>
      适当地使用 CLOS。
    </SUMMARY>
    <BODY>
      <p>
        当一个通用函数打算被其它模组调用时（其它部分的代码），
        应该要有一个显式的 <code>DEFGENERIC</code> 形式，
        以及一个 <code>:DOCUMENTATION</code> 字串解釋函數的通用合約
        （與某些特定類別解釋行為相反）。
        一般寫显式的<code>DEFGENERIC</code> 形式是好的，
        但在模組进入点來說是必须要写的。
      </p>
      <p>
        当通用函数的参数列表包含了
        <code>&amp;KEY</code> 时，
        <code>DEFGENERIC</code> 应总是将所有可接受的关键字参数列出来，
        并解释它们各代表著什么。
        （Common Lisp 没有要求这么做，
        但从可以避免 SBCL 产生不实的警告来说，这么做是好的。）
      </p>
      <p>
        你应该避免使用 <code>SLOT-VALUE</code> 以及 <code>WITH-SLOTS</code>，
        除非你完全想要回避，任何种类的方法结合对槽带来的影响。
        稀少的例外包括了
        <code>INITIALIZE-INSTANCE</code> 以及 <code>PRINT-OBJECT</code> 方法，
        还有访问隐藏在底层里，提供用户可视抽象的实现方法。
        不然你应该使用
        <code>WITH-ACCESSORS</code> 访问器。
      </p>  
      <p>
        访问器的名称一般遵循 
        <code>&lt;protocol-name&gt;-&lt;slot-name&gt;</code> 的惯例，
        其中"协议"在这个情况下，松散地指出了一组行为定义良好的函数。
      </p>
      <p><!--- NTR, Need To Refactor-->
        是需要把正式的"协议"概念设计成不可实作，
        就像第一类"协议"的对象没有实作那样。
        但也可以是一个抽象 CLOS 类，或是一个嵌入协议的 
        <a href="http://common-lisp.net/~frideau/lil-ilc2012/lil-ilc2012.html">Interface-Passing Style</a> 介面。
        之后的（子）类或（子）介面，则可以通过给协议中的（通用）函数，
        定义某些方法来实现协议部分或全部内容，包含了读取器及写入器。
      </p>
      <p><!--- NTR, Need To Refactor-->
        举例来说，如果有一个象徵性的协议称为
        <code>pnr</code> ，有著访问器：
        <code>pnr-segments</code>、<code>pnr-passengers</code> 以及
        <code>pnr-passengers</code> ，则
        <code>air-pnr</code>、<code>hotel-pnr</code> 及
        <code>car-pnr</code> 类别只能给
        <code>pnr-segments</code> 及 <code>pnr-passengers</code> 合理地实作方法，
        来作为访问器。
      </p>
      <p>
        默认行为下，抽象基类名称拿来作为象徵性的协议名，
        所以访问器名称默认是 <code>&lt;class-name&gt;-&lt;slot-name&gt;</code>；
        当这些名称常常使用时，
        就不再偏好或需要用这个形式。
        一般来说呢，这使得符号名"更长了"，<!--symbol bloat-->
        而且在许多情况里，会导致 "trampoline" 方法散布开来。
      </p>
      <p>
        不应该使用由 <code>&lt;slot-name&gt;-of</code> 命名的访问器。
      </p>
      <p>
        显式的 <code>DEFGENERIC</code> 形式应在通用方法
        （或是将来可能）超过一个以上的 <code>DEFMETHOD</code> 情况使用。
        这个理由是通用函数的文档解释函数的抽象合约，
        而不是解释每个方法给哪些具体的类别做什么。
      </p>
      <p>
        再没有一个象徵性协议时，绝对不要使用通用函数。
        更具体来说，如果你有超过一个通用函数，且特化 N 个参数，
        所有正特化的类别，全部都应当是一个单类的子孙。
        通用函数绝对不要用来实现"重载"，也就是说，
        只在拿来表示两个完全无关的类别的情况下使用。
      </p>
      <p>
        更精确的说，并不是他们需要从一个常见的超类演化而来，
        而是他们需要遵守同样的"协议"。
        也就是两个类别应处理同一组通用函数，
        就像是每个方法都有一个显式的 <code>DEFGENERIC</code> 存在一样。
      </p>
      <p>
        以下是另一种说法。
        假设你有两个类别，甲跟乙，以及一个通用函数丁。
        丁有两个方法，分别派发类型甲与乙的参数。
        也许在程序的某个地方，有个函数调用了丁，
        而传入的参数可能在运行期时，
        属于类别甲，而某些时候属于类别乙，这样是合理的吗？
        如果不合理的话，你可能正在使用重载，而且你不应使用单个通用函数。
      </p>
      <p><!--- NTR -->
        这个规则有一个例外：
        如果相应的参数代表同样事情时，用重载是没问题的。
        通常一个重载会接受一个 X 对象，
        以及其他接受 X 对象名称的对象，
        可能是符号或是别的。
      </p>
      <p><!--- NTR -->
        绝对不要在运行期使用 <a HREF="http://en.wikipedia.org/wiki/Metaobject#Metaobject_protocol">MOP</a> 的"调停"操作。
        在编译期你也不应该使用 MOP 的"调停"操作。
        在运行期时，MOP 的调停操作，
        在最坏的情况下是个危险，最好的情况下是个效能问题。
        在编译期时，宏应在第一轮就把事情办到定位，
        而不是需要第二轮透过调停操作来事后修补；
        但某些时候，修补是解决向前引用的必要手段，
        且此时调停操作是允许的。
        MOP 的调停对于互动式开发来说是一个极好的工具，
        且你可以在开发及调试的过程中享受它的美妙；
        但你不应当在一般应用里使用。
      </p>
      <p>
        如果类定义创建了一个作为
        <code>:READER</code>、<code>:WRITER</code>,
        或是 <code>:ACCESSOR</code> 的方法，不要重定义该方法。
        加入 <code>:BEFORE</code>、<code>:AFTER</code>
        以及 <code>:AROUND</code> 这些辅助方法是可以的，
        但不要重写主要方法。
      </p>
      <p>
        在有关键字参数的方法里，
        你必须永远使用 <code>&amp;KEY</code>，
        即便是方法不在乎键的值是什么，
        你也永远不应该使用 <code>&amp;ALLOW-OTHER-KEYS</code>。
        只要关键字被任何通用函数的方法所接受时，
        在通用函数里使用它是 OK 的，
        即使同样的通用函数没有特别提到它。
        这对于 <code>INITIALIZE-INSTANCE</code> 方法来说特别重要，
        若是你使用了 <code>&amp;ALLOW-OTHER-KEYS</code>，
        这会把调用 <code>MAKE-INSTANCE</code> 时，
        检查拼错或是错误关键字的错误禁能！
      </p>      
      <p>
        一个典型的 <code>PRINT-OBJECT</code> 方法看起来可能像是这样：
      </p>
      <CODE_SNIPPET>
        (defmethod print-object ((p person) stream)
          (print-unprintable-object (p stream :type t :identity t)
            (with-slots (first-name last-name) p
              (safe-format stream "~a ~a" first-name last-name))))
      </CODE_SNIPPET>
    </BODY>
  </STYLEPOINT>
</CATEGORY>
<CATEGORY title="元语言准则">
  <STYLEPOINT title="宏">
    <SUMMARY>
      在适当的时机使用宏，这种情况很常见。
      在适当的实机定义宏，这种情况不太多。
    </SUMMARY>
    <BODY>
      <p>
        Macros bring syntactic abstraction, which is a wonderful thing.
        It helps make your code clearer, by describing your intent
        without getting bogged in implementation details
        (indeed abstracting those details away).
        It helps make your code more concise and more readable,
        by eliminating both redundancy and irrelevant details.
        But it comes at a cost to the reader,
        which is learning a new syntactic concept for each macro.
        And so it should not be abused.
      </p>
      <p>
        The general conclusion is that there shouldn't be
        any recognizable <em>design pattern</em>
        in a good Common Lisp program.
        The one and only pattern is: <em>use the language</em>,
        which includes defining and using syntactic abstractions.
      </p>
      <p>
        Existing macros must be used
        whenever they make code clearer
        by conveying intent in a more concise way,
        which is often.
        When a macro is available in your project
        that expresses the concept you're using,
        you must not write the expansion rather than use the macro.
      </p>
      <p>
        New macros should be defined as appropriate,
        which should be seldom,
        for common macros have already been provided
        by the language and its various libraries,
        and your program typically only needs few new ones
        relative to its size.
      </p>
      <p>
        You should follow the OAOOM rule of thumb
        for deciding when to create a new abstraction,
        whether syntactic or not:
        if a particular pattern is used more than twice,
        it should probably be abstracted away.
        A more refined rule to decide when to use abstraction
        should take into account
        the benefit in term of number of uses and gain at each use,
        to the costs in term of having to get used to reading the code.
        For syntactic abstractions, costs and benefits to the reader
        is usually more important than costs and benefits to the writer,
        because good code is usually written once
        and read many times by many people
        (including the same programmer
        who has to maintain the program after having forgotten it).
        Yet the cost to the writer of the macro
        should also be taken into account;
        however, in doing so it should rather be compared
        to the cost of the programmer writing other code instead
        that may have higher benefits.
      </p>
      <p>
        Using Lisp macros properly requires taste.
        Avoid writing complicated macros
        unless the benefit clearly outweighs the cost.
        It takes more effort for your fellow developers to learn your macro,
        so you should only use a macro if the gain in expressiveness
        is big enough to justify that cost.
        As usual, feel free to consult your colleagues if you're not sure,
        since without a lot of Lisp experience,
        it can be hard to make this judgment.
      </p>
      <p>
        You must never use a macro where a function will do.
        That is, if the semantics of what you are writing
        conforms to the semantics of a function,
        then you must write it as a function rather than a macro.
      </p>
      <p>
        You must not transform a function into a macro for performance reasons.
        If profiling shows that you have a performance problem
        with a specific function <code>FOO</code>,
        document the need and profiling-results appropriately,
        and
        <code>(declaim (inline foo))</code>.
      </p>
      
      <p>
        You can also use a compiler-macro
        as a way to speed up function execution
        by specifying a source-to-source transformation.
        Beware that it interferes with tracing the optimized function.
      </p>
      <p>
        When you write a macro-defining macro
        (a macro that generates macros),
        document and comment it particularly clearly,
        since these are hard for the uninitiated to understand.
      </p>
      <p>
        You must not install new reader macros
        without a consensus among the developers of your system.
        Reader macros must not leak out of the system that uses them
        to clients of that system or other systems used in the same project.
        You must software such as
        <code>cl-syntax</code> or <code>named-readtables</code>
        to control how reader macros are used.
        This clients who desire it may use the same reader macros as you do.
        In any case, your system must be usable
        even to clients who do not use these reader macros.
      </p>
      <p>
        If your macro has a parameter that is a Lisp form
        that will be evaluated when the expanded code is run,
        you should name the parameter with the suffix <code>-form</code>.
        This convention helps make it clearer to the macro's user
        which parameters are Lisp forms to be evaluated, and which are not.
      </p>
      <p>
        You should follow the so-called <code>CALL-WITH</code> style when it applies.
        This style is explained at length in
        <a href="http://random-state.net/log/3390120648.html">http://random-state.net/log/3390120648.html</a>.
        The general principle is that the macro is strictly limited to processing the syntax,
        and as much of the semantics as possible is kept in normal functions.
        Therefore, a macro <code>WITH-<em>FOO</em></code> is often limited to
        generating a call to an auxiliary function
        <code>CALL-WITH-<em>FOO</em></code>
        with arguments deduced from the macro arguments.
        Macro <code>&amp;body</code> arguments are typically
        wrapped into a lambda expression of which they become the body,
        which is passed as one of the arguments of the auxiliary function.
      </p>
      <p>
        The separation of syntactic and semantic concerns
        is a general principle of style that applies
        beyond the case of <code>WITH-</code> macros.
        Its advantages are many.
        By keeping semantics outside the macro,
        the macro is made simpler, easier to get right, and less subject to change,
        which makes it easier to develop and maintain.
        The semantics is written in a simpler language &#8212; one without staging &#8212;
        which also makes it easier to develop and maintain.
        It becomes possible to debug and update the semantic function
        without having to recompile all clients of the macro.
        The semantic function appears in the stack trace
        which also helps debug client functions.
        The macro expansion is made shorter and
        each expansion shares more code with other expansions,
        which reduces memory pressure which in turn usually makes things faster.
        It also makes sense to write the semantic functions first,
        and write the macros last as syntactic sugar on top.
        You should use this style unless the macro is used
        in tight loops where performance matters;
        and even then, see our rules regarding optimization.
      </p>
      <p>
        Any functions (closures) created by the macro should be named,
        which can be done using <code>FLET</code>.
        
        This also allows you to declare the function to be of dynamic extent
        (if it is &#8212; and often it is; yet see below regarding
        <a href="#DYNAMIC-EXTENT">DYNAMIC-EXTENT</a>).
      </p>
      <p>
        If a macro call contains a form,
        and the macro expansion includes more than one copy of that form,
        the form can be evaluated more than once,
        and code it contains macro-expanded and compiled more than once.
        If someone uses the macro and calls it
        with a form that has side effects or that takes a long time to compute,
        the behavior will be undesirable
        (unless you're intentionally writing
        a control structure such as a loop).
        A convenient way to avoid this problem
        is to evaluate the form only once,
        and bind a (generated) variable to the result.
        There is a very useful macro called <code>ALEXANDRIA:ONCE-ONLY</code>
        that generates code to do this.
        See also <code>ALEXANDRIA:WITH-GENSYMS</code>,
        to make some temporary variables in the generated code.
        Note that if you follow our <code>CALL-WITH</code> style,
        you typically expand the code only once, as either
        an argument to the auxiliary function, or
        the body of a lambda passed as argument to it;
        you therefore avoid the above complexity.
      </p>
      <p>
        When you write a macro with a body,
        such as a <code>WITH-xxx</code> macro,
        even if there aren't any parameters,
        you should leave space for them anyway.
        For example, if you invent <code>WITH-LIGHTS-ON</code>,
        do not make the call to it look like
        <code>(defmacro with-lights-on (&amp;body b) ...)</code>.
        Instead, do <code>(defmacro with-lights-on (() &amp;body b) ...)</code>.
        That way, if parameters are needed in the future,
        you can add them without necessarily having to change
        all the uses of the macro.
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="何时求值">
    <SUMMARY>
      当使用 <code>EVAL-WHEN</code> 时，你应该总是使用所有的
      <code>(:compile-toplevel :load-toplevel :execute)</code>.
    </SUMMARY>
    <BODY>
      <p>
        Lisp evaluation happens at several times,
        some of them interleaved.
        Be aware of them when writing macros.
        <a href="http://fare.livejournal.com/146698.html">EVAL-WHEN considered harmful to your mental health</a>.
      </p>
      <p>
        In summary of the article linked above,
        unless you're doing truly advanced macrology,
        the only valid combination in an <code>EVAL-WHEN</code>
        is to include all of
        <code>(eval-when (:compile-toplevel :load-toplevel :execute) ...)</code>
      </p>
      <p>
        You must use
        <code>(eval-when (:compile-toplevel :load-toplevel :execute) ...)</code>
        whenever you define functions, types, classes, constants, variables, etc.,
        that are going to be used in macros.
      </p>
      <p>
        It is usually an error to omit the <code>:execute</code>,
        because it prevents <code>LOAD</code>ing the source rather than the fasl.
        It is usually an error to omit the <code>:load-toplevel</code>
        (except to modify e.g. readtables and compile-time settings),
        because it prevents <code>LOAD</code>ing future files
        or interactively compiling code
        that depends on the effects that happen at compile-time,
        unless the current file was <code>COMPILE-FILE</code>d
        within the same Lisp session.
      </p>
      <p>
        Regarding variables, note that because macros may or may not
        be expanded in the same process that runs the expanded code,
        you must not depend on compile-time and runtime effects
        being either visible or invisible at the other time.
        There are still valid uses of variables in macros:
      </p>
      <ul>
        <li>
          Some variables may hold dictionaries
          for some new kind of definition and other meta-data.
          If such meta-data is to be visible at runtime and/or in other files,
          you must make sure that the macro expands into code that
          will register the definitions to those meta-data structures
          at load-time,
          in addition to effecting the registration at compile-time.
          Typically, your top-level definitions expand
          to code that does the registration.
          if your code doesn't expand at the top-level,
          you can sometimes use <code>LOAD-TIME-VALUE</code> for good effect.
          In extreme cases, you may have to use
          <code>ASDF-FINALIZERS:EVAL-AT-TOPLEVEL</code>.
        </li>
        <li>
          Some variables may hold temporary data
          that is only used at compile-time in the same file,
          and can be cleaned up at the end of the file's compilation.
          Predefined such variables would include <code>*readtable*</code>
          or compiler-internal variables holding
          the current optimization settings.
          You can often manage existing and new such variables using
          the <code>:AROUND-COMPILE</code> hooks of <code>ASDF</code>.
        </li>
      </ul>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="读取期求值">
    <SUMMARY>
      你应该节制地使用 <code>#.</code> 并必须避免读取期的副作用。
    </SUMMARY>
    <BODY>
      <p>
        The <code>#.</code> standard read-macro
        will read one object, evaluate the object, and
        have the reader return the resulting value.
      </p>
      <p>
        You must not use it where other idioms will do, such as
        using <code>EVAL-WHEN</code> to evaluate side-effects at compile-time,
        using a regular macro to return an expression computed at compile-time,
        using <code>LOAD-TIME-VALUE</code> to compute it at load-time.
      </p>
      <p>
        Read-time evaluation is often used as a quick way
        to get something evaluated at compile time
        (actually "read time" but it amounts to the same thing).
        If you use this, the evaluation MUST NOT have any side effects
        and MUST NOT depend on any variable global state.
        The <code>#.</code> should be treated as a way
        to force "constant-folding"
        that a sufficiently-clever compiler
        could have figure out all by itself,
        when the compiler isn't sufficiently-clever
        and the difference matters.
      </p>
      <p>
        Another use of <code>#.</code> is to expand the equivalent of macros
        in places that are neither expressions nor (quasi)quotations,
        such as lambda-lists. However, if you find yourself using it a lot,
        it might be time to instead define macros to replace your consumers
        of lambda-lists with something that recognizes an extension.
      </p>
      <p>
        Whenever you are going to use <code>#.</code>,
        you should consider using <code>DEFCONSTANT</code> and its variants,
        possibly in an <code>EVAL-WHEN</code>,
        to give the value a name explaining what it means.
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="求值">
    <SUMMARY>
      绝对不要在运行期使用 <code>EVAL</code>。
    </SUMMARY>
    <BODY>
      <p>
        Places where it is actually appropriate to use <code>EVAL</code>
        are so few and far between that you must consult with your reviewers;
        it's easily misused.
      </p>
      <p>
        If your code manipulates symbols at runtime
        and needs to get the value of a symbol,
        use <code>SYMBOL-VALUE</code>, not <code>EVAL</code>.
      </p>
      <p>
        Often, what you really need is to write a macro,
        not to use <code>EVAL</code>.
      </p>
      <p>
        You may be tempted to use <code>EVAL</code> as a shortcut
        to evaluating expressions in a safe subset of the language.
        But it often requires more scrutiny to properly check and sanitize
        all possible inputs to such use of <code>EVAL</code>
        than to build a special-purpose evaluator.
        You must not use <code>EVAL</code> in this way at runtime.
      </p>
      <p>
        Places where it is OK to use <code>EVAL</code> are:
      </p>
      <ul>
        <li>
          Implementing an interactive development loop.
        </li>
        <li>
          The build infrastructure.
        </li>
        <li>
          Backdoors that are part of testing frameworks.
          (You MUST NOT have such backdoors in production code.)
        </li>
        <li>
          Macros that fold constants at compile-time.
        </li>
        <li>
          Macros that register definitions to meta-data structures;
          the registration form is sometimes evaluated at compile-time
          as well as included in the macro-expansion,
          so it is immediately available to other macros.
        </li>
      </ul>
      <p>
        Note that in the latter case,
        if the macro isn't going to be used at the top-level,
        it might not be possible to make these definitions available
        as part of the expansion.
        The same phenomenon may happen in a <code>DEFTYPE</code> expansion,
        or in helper functions used by macros.
        In these cases, you may actually have to use
        <code>ASDF-FINALIZERS:EVAL-AT-TOPLEVEL</code> in your macro.
        It will not only <code>EVAL</code> your definitions
        at macro-expansion time for immediate availability,
        it will also save the form aside, for inclusion in a
        <code>(ASDF-FINALIZERS:FINAL-FORMS)</code>
        that you need to include at the end of the file being compiled
        (or before the form is needed).
        This way, the side-effects are present when loading the fasl
        without having compiled it as well as while compiling it;
        in either case, the form is made available at load-time.
        <code>ASDF-FINALIZERS</code> ensures that the form is present,
        by throwing an error if you omit it.
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="导入与导出">
    <SUMMARY>
      绝对不要在运行期使用 <code>INTERN</code> 或 <code>UNINTERN</code>。
    </SUMMARY>
    <BODY>
      <p>
        You must not use <code>INTERN</code> at runtime.
        Not only does it cons,
        it either creates a permanent symbol that won't be collected
        or gives access to internal symbols.
        This creates opportunities for memory leaks, denial of service attacks,
        unauthorized access to internals, clashes with other symbols.
      </p>
      <p>
        You must not <code>INTERN</code> a string
        just to compare it to a keyword;
        use <code>STRING=</code> or <code>STRING-EQUAL</code>.
      </p>
      <BAD_CODE_SNIPPET>
        (member (intern str :keyword) $keys) ; Bad
      </BAD_CODE_SNIPPET>
      <CODE_SNIPPET>
        (member str $keys :test #'string-equal) ; Better
      </CODE_SNIPPET>
      <p>
        You must not use <code>UNINTERN</code> at runtime.
        It can break code that relies on dynamic binding.
        It makes things harder to debug.
        You must not dynamically intern any new symbol,
        and therefore you need not dynamically unintern anything.
      </p>
      <p>
        You may of course use <code>INTERN</code> at compile-time,
        in the implementation of some macros.
        Even so, it is usually more appropriate
        to use abstractions on top of it, such as
        <code>ALEXANDRIA:SYMBOLICATE</code> or
        <code>ALEXANDRIA:FORMAT-SYMBOL</code>
        to create the symbols you need.
      </p>
    </BODY>
  </STYLEPOINT>
</CATEGORY>
<CATEGORY title="表示数据">
  <STYLEPOINT title="NIL: 空表、假、以及我不知道">
    <SUMMARY>
      适当地使用或避免使用 NIL。
    </SUMMARY>
    <BODY>
      <p>
        <code>NIL</code> 可以有几个不同的解读：
      </p>
      <ul>
        <li>
          "逻辑假"
          In this case, use <code>NIL</code>.
          You should test for false <code>NIL</code>
          using the operator <code>NOT</code> or
          using the predicate function <code>NULL</code>.
        </li>
        <li>
          "空列表"
          In this case, use <code>'()</code>.
          (Be careful about quoting the empty-list when calling macros.)
          You should use <code>ENDP</code> to test for the empty list
          when the argument is known to be a proper list,
          or with <code>NULL</code> otherwise.
        </li>
        <li>
          A statement about some value being unspecified.
          In this case, you may use <code>NIL</code>
          if there is no risk of ambiguity anywhere in your code;
          otherwise you should use an explicit, descriptive symbol.
        </li>
        <li>
          A statement about some value being known not to exist.
          In this case, you should use an explicit, descriptive symbol
          instead of <code>NIL</code>.
        </li>
      </ul>
      <p>
        You must not introduce ambiguity in your data representations
        that will cause headaches for whoever has to debug code.
        If there is any risk of ambiguity,
        you should use an explicit, descriptive symbol or keyword
        for each case,
        instead of using <code>NIL</code> for either.
        If you do use <code>NIL</code>,
        you must make sure that the distinction is well documented.
      </p>
      <p>
        In many contexts,
        instead of representing "I don't know" as a particular value,
        you should instead use multiple values,
        one for the value that is known if any,
        and one to denote whether the value was known or found.
      </p>
      
      <p>
        When working with database classes, keep in mind that
        <code>NIL</code> need not always map to <code>'NULL'</code>
        (and vice-versa)!
        The needs of the database may differ from the needs of the Lisp.
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="别滥用列表">
    <SUMMARY>
      必须正确选择数据的表示法。
      绝对不要滥用 <code>LIST</code> 数据结构。
    </SUMMARY>
    <BODY>
      <p>
        Even though back in 1958, LISP was short for "LISt Processing",
        its successor Common Lisp has been a modern programming language
        with modern data structures since the 1980s.
        You must use the proper data structures in your programs.
      </p>
      <p>
        You must not abuse the builtin (single-linked) <code>LIST</code>
        data structure where it is not appropriate,
        even though Common Lisp makes it especially easy to use it.
      </p>
      <p>
        You must only use lists
        when their performance characteristics
        is appropriate for the algorithm at hand:
        sequential iteration over the entire contents of the list.
      </p>
      <p>
        An exception where it is appropriate to use lists
        is when it is known in advance
        that the size of the list will remain very short
        (say, less than 16 elements).
      </p>
      <p>
        List data structures are often (but not always)
        appropriate for macros and functions used by macros at compile-time:
        indeed, not only is source code passed as lists in Common Lisp,
        but the macro-expansion and compilation processes
        will typically walk over the entire source code, sequentially, once.
        (Note that advanced macro systems don't directly use lists, but instead
        use abstract syntax objects that track source code location and scope;
        however there is no such advanced macro system
        in Common Lisp at this time.)
      </p>
      <p>
        Another exception where it is appropriate to use lists is
        for introducing literal constants
        that will be transformed into more appropriate data structures
        at compile-time or load-time.
        It is a good to have a function with a relatively short name
        to build your program's data structures from such literals.
      </p>
      <p>
        In the many cases when lists are not the appropriate data structure,
        various libraries such as
        <a href="http://cliki.net/cl-containers">cl-containers</a> or
        <a href="http://cliki.net/lisp-interface-library">lisp-interface-library</a>
        provide plenty of different data structures
        that should fulfill all the basic needs of your programs.
        If the existing libraries are not satisfactory, see above about
        <a href="#Using_Libraries">Using Libraries</a> and
        <a href="#Open-Sourcing_Code">Open-Sourcing Code</a>.
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="列表 x 结构 x 多值">
    <SUMMARY>
      你应该使用恰当的表示法，来表示多个类型。
    </SUMMARY>
    <BODY>
      <p>
        You should avoid using a list as anything
        besides a container of elements of like type.
        You must not use a list as method of passing
        multiple separate values of different types
        in and out of function calls.
        Sometimes it is convenient to use a list
        as a little ad hoc structure,
        i.e. "the first element of the list is a FOO, and the second is a BAR",
        but this should be used minimally
        since it gets harder to remember the little convention.
        You must only use a list that way
        when destructuring the list of arguments from a function,
        or creating a list of arguments
        to which to <code>APPLY</code> a function.
      </p>
      <p>
        The proper way to pass around an object
        comprising several values of heterogeneous types
        is to use a structure as defined by <code>DEFSTRUCT</code>
        or <code>DEFCLASS</code>.
      </p>
      <p>
        You should use multiple values only
        when function returns a small number of values
        that are meant to be destructured immediately by the caller,
        rather than passed together as arguments to further functions.
      </p>
      <p>
        You should not return a condition object
        as one of a set of multiple values.
        Instead, you should signal the condition to denote an unusual outcome.
      </p>
      <p>
        You should signal a condition to denote an unusual outcome,
        rather than relying on a special return type.
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="列表 x 点对">
    <SUMMARY>
      当操作列表时，使用恰当的函数。
    </SUMMARY>
    <BODY>
      <p>
        Use <code>FIRST</code> to access the first element of a list,
        <code>SECOND</code> to access the second element, etc.
        Use <code>REST</code> to access the tail of a list.
        Use <code>ENDP</code> to test for the end of the list.
      </p>
      <p>
        Use <code>CAR</code> and <code>CDR</code>
        when the cons cell is not being used to implement a proper list
        and is instead being treated as a pair of more general objects.
        Use <code>NULL</code> to test for <code>NIL</code> in this context.
      </p>
      <p>
        The latter case should be rare outside of alists,
        since you should be using structures and classes where they apply,
        and data structure libraries when you want trees.
      </p>
      <p>
        Exceptionally, you may use <code>CDADR</code> and other variants
        on lists when manually destructuring them,
        instead of using a combination of several list accessor functions.
        In this context, using <code>CAR</code> and <code>CDR</code>
        instead of <code>FIRST</code> and <code>REST</code> also makes sense.
        However, keep in mind that it might be more appropriate in such cases
        to use higher-level constructs such as
        <code>DESTRUCTURING-BIND</code> or <code>FARE-MATCHER:MATCH</code>.
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="列表 x 数组">
    <SUMMARY>
      当随机访问很重要时，使用数组而不是列表。
    </SUMMARY>
    <BODY>
      <p>
        <code>ELT</code> has <i>O(n)</i> behavior when used on lists.
        If you are to use random element access on an object,
        use arrays and <code>AREF</code> instead.
      </p>
      <p>
        The exception is for code outside the critical path
        where the list is known to be small anyway.
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="列表 x 集合">
    <SUMMARY>
      你应该只在长度非常小的情况下，将列表作为集合使用。
    </SUMMARY>
    <BODY>
      <p>
        Using lists as representations of sets is a bad idea
        unless you know the lists will be small,
        for accessors are <i>O(n)</i> instead of <i>O(log n)</i>.
        For arbitrary big sets, use balanced binary trees,
        for instance using <code>lisp-interface-library</code>.
      </p>
      <p>
        If you still use lists as sets,
        you should not <code>UNION</code> lists just to search them.
      </p>
      <BAD_CODE_SNIPPET>
        (member foo (union list-1 list-2)) ; Bad
      </BAD_CODE_SNIPPET>
      <CODE_SNIPPET>
        (or (member foo list-1) (member foo list-2)) ; Better
      </CODE_SNIPPET>
      <p>
        Indeed, <code>UNION</code> not only conses unnecessarily,
        but it can be <i>O(n^2)</i> on some implementations,
        and is rather slow even when it's <i>O(n)</i>.
      </p>
    </BODY>
  </STYLEPOINT>
</CATEGORY>
<CATEGORY title="适当形式">
  <p>
    你必须遵循函数、宏以及特殊形式的正确使用方式。
  </p>
  <STYLEPOINT title="定义常量">
    <SUMMARY>
      你必须给常量值使用正确的定义形式。
    </SUMMARY>
    <BODY>
      <p>
        The Lisp system we primarily use, SBCL, is very picky and
        signals a condition whenever a constant is redefined to a value not
        <code>EQL</code> to its previous setting.
        You must not use <code>DEFCONSTANT</code>
        when defining variables that are not
        numbers, characters, or symbols (including booleans and keywords).
        Instead, consistently use whichever alternative
        is recommended for your project.
      </p>
      <BAD_CODE_SNIPPET>
        ;; Bad
        (defconstant +google-url+ "http://www.google.com/")
        (defconstant +valid-colors+ '(red green blue))
      </BAD_CODE_SNIPPET>
      
      
      
      
      <p>
        Open-Source libraries may use
        <code>ALEXANDRIA:DEFINE-CONSTANT</code>
        for constants other than numbers, characters and symbols
        (including booleans and keywords).
        You may use the <code>:TEST</code> keyword argument
        to specify an equality predicate.
      </p>
      <CODE_SNIPPET>
        ;; Better, for Open-Source code:
        (define-constant +google-url+ "http://www.google.com/" :test #'string=)
        (define-constant +valid-colors+ '(red green blue))
      </CODE_SNIPPET>
      <p>
        Note that with optimizing implementations, such as SBCL or CMUCL,
        defining constants this way precludes any later redefinition
        short of <code>UNINTERN</code>ing the symbol
        and recompiling all its clients.
        This may make it "interesting" to debug things at the REPL
        or to deploy live code upgrades.
        If there is a chance that your "constants" are not going to be constant
        over the lifetime of your server processes
        after taking into consideration scheduled and unscheduled code patches,
        you should consider using
        <code>DEFPARAMETER</code> or <code>DEFVAR</code> instead,
        or possibly a variant of <code>DEFINE-CONSTANT</code>
        that builds upon some future library implementing global lexicals
        rather than <code>DEFCONSTANT</code>.
        You may keep the <code>+plus+</code> convention in these cases
        to document the intent of the parameter as a constant.
      </p>
      <p>
        Also note that <code>LOAD-TIME-VALUE</code> may help you
        avoid the need for defined constants.
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="定义函数">
    <SUMMARY>
      你应该正确使用
      <code>&amp;OPTIONAL</code>,
      <code>&amp;KEY</code>,
      以及
      <code>&amp;AUX</code> 参数。
    </SUMMARY>
    <BODY>
      <p>
        You should avoid using <code>&amp;ALLOW-OTHER-KEYS</code>,
        since it blurs the contract of a function.
        Almost any real function (generic or not) allows a certain
        fixed set of keywords, as far as its caller is concerned,
        and those are part of its contract.
        If you are implementing a method of a generic function,
        and it does not need to know
        the values of some of the keyword arguments,
        you should explicitly <code>(DECLARE (IGNORE ...))</code>
        all the arguments that you are not using.
        You must not use <code>&amp;ALLOW-OTHER-KEYS</code>
        unless you explicitly want to disable checking of allowed keys
        for all methods when invoking the generic function on arguments
        that match this particular method.
        Note that the contract of a generic function belongs in
        the <code>DEFGENERIC</code>, not in the <code>DEFMETHOD</code>
        which is basically an "implementation detail" of the generic function
        as far as the caller of the generic is concerned.
      </p>
      <p>
        A case where <code>&amp;ALLOW-OTHER-KEYS</code> is appropriate
        is when you write a wrapper function to other some other functions
        that may vary (within the computation or during development),
        and pass around a plist as a <code>&amp;REST</code> argument.
      </p>
      <p>
        You should avoid using <code>&amp;AUX</code> arguments,
        except in very short helper functions
        where they allow you to eschew a <code>LET</code>.
      </p>
      <p>
        You should avoid having both <code>&amp;OPTIONAL</code>
        and <code>&amp;KEY</code> arguments,
        unless it never makes sense to specify keyword arguments
        when the optional arguments are not all specified.
        You must not have non-<code>NIL</code> defaults
        to your <code>&amp;OPTIONAL</code> arguments
        when your function has both <code>&amp;OPTIONAL</code>
        and <code>&amp;KEY</code> arguments.
      </p>
      <p>
        For maximum portability of a library, it is good form
        that <code>DEFMETHOD</code> definitions should
        <code>(DECLARE (IGNORABLE ...))</code>
        all the required arguments that they are not using.
        Indeed, some implementations will issue a warning
        if you <code>(DECLARE (IGNORE ...))</code> those arguments,
        whereas other implementations will issue a warning
        if you fail to <code>(DECLARE (IGNORE ...))</code> them.
        <code>(DECLARE (IGNORABLE ...))</code> works on all implementations.
      </p>
      <p>
        You should avoid excessive nesting of binding forms inside a function.
        If your function ends up with massive nesting,
        you should probably break it up into several functions or macros.
        If it is really a single conceptual unit,
        consider using a macro such as <code>FARE-UTILS:NEST</code>
        to at least reduce the amount of indentation required.
        It is bad form to use <code>NEST</code> in typical short functions
        with 4 or fewer levels of nesting,
        but also bad form not to use it in the exceptional long functions
        with 10 or more levels of nesting.
        Use your judgment and consult your reviewers.
      </p>     
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="条件表达式">
    <SUMMARY>
      使用恰当的条件表达式。
    </SUMMARY>
    <BODY>
      <p>
        Use <code>WHEN</code> and <code>UNLESS</code>
        when there is only one alternative.
        Use <code>IF</code> when there are two alternatives
        and <code>COND</code> when there are several.
      </p>
      <p>
        However, don't use <code>PROGN</code> for an <code>IF</code> clause
        &#8212; use <code>COND</code>, <code>WHEN</code>, or <code>UNLESS</code>.
      </p>
      <p>
        Note that in Common Lisp,
        <code>WHEN</code> and <code>UNLESS</code> return <code>NIL</code>
        when the condition is not met.
        You may take advantage of it.
        Nevertheless, you may use an <code>IF</code>
        to explicitly return <code>NIL</code>
        if you have a specific reason to insist on the return value.
        You may similarly include a fall-through clause <code>(t nil)</code>
        as the last in your <cond>COND</cond>,
        or <code>(otherwise nil)</code> as the last in your <cond>CASE</cond>,
        to insist on the fact that the value returned by the conditional matters
        and that such a case is going to be used.
        You should omit the fall-through clause
        when the conditional is used for side-effects.
      </p>
      <p>
        You should prefer <code>AND</code> and <code>OR</code>
        when it leads to more concise code than using
        <code>IF</code>, <code>COND</code>,
        <code>WHEN</code> or <code>UNLESS</code>,
        and there are no side-effects involved.
        You may also use an <code>ERROR</code>
        as a side-effect in the final clause of an <code>OR</code>.
      </p>
      <p>
        You should only use <code>CASE</code> and <code>ECASE</code>
        to compare numbers, characters or symbols
        (including booleans and keywords).
        Indeed, <code>CASE</code> uses <code>EQL</code> for comparisons,
        so strings, pathnames and structures may not compare the way you expect,
        and <code>1</code> will differ from <code>1.0</code>.
      </p>
      <p>
        You should use <code>ECASE</code> and <code>ETYPECASE</code>
        in preference to <code>CASE</code> and <code>TYPECASE</code>.
        It is better to catch erroneous values early.
      </p>
      <p>
        You should not use <code>CCASE</code> or <code>CTYPECASE</code> at all.
        At least, you should not use them in server processes,
        unless you have quite robust error handling infrastructure
        and make sure not to leak sensitive data this way.
        These are meant for interactive use,
        and can cause interesting damage
        if they cause data or control leak to attackers.
      </p>
      <p>
        You must not use gratuitous single quotes in <code>CASE</code> forms.
        This is a common error:
      </p>
      <BAD_CODE_SNIPPET>
        (case x ; Bad: silently returns NIL on mismatch
          ('bar :bar) ; Bad: catches QUOTE
          ('baz :baz)) ; Bad: also would catch QUOTE
      </BAD_CODE_SNIPPET>
      <CODE_SNIPPET>
        (ecase x ; Better: will error on mismatch
          ((bar) :bar) ; Better: won't match QUOTE
          ((baz) :baz)) ; Better: same reason
      </CODE_SNIPPET>
      <p>
        <code>'BAR</code> there is <code>(QUOTE BAR)</code>,
        meaning this leg of the case will be executed
        if <code>X</code> is <code>QUOTE</code>...
        and ditto for the second leg
        (though <code>QUOTE</code> will be caught by the first clause).
        This is unlikely to be what you really want.
      </p>
      <p>
        In <code>CASE</code> forms,
        you must use <code>otherwise</code> instead of <code>t</code>
        when you mean "execute this clause if the others fail".
        You must use <code>((t) ...)</code>
        when you mean "match the symbol T" rather than "match anything".
        You must also use <code>((nil) ...)</code>
        when you mean "match the symbol NIL" rather than "match nothing".
      </p>
      <p>
        Therefore, if you want to map booleans <code>NIL</code> and <code>T</code>
        to respective symbols <code>:BAR</code> and <code>:QUUX</code>,
        you should avoid the former way and do it the latter way:
      </p>
      <BAD_CODE_SNIPPET>
        (ecase x ; Bad: has no actual error case!
          (nil :bar)) ; Bad: matches nothing
          (t :quux)) ; Bad: matches anything
      </BAD_CODE_SNIPPET>
      <CODE_SNIPPET>
        (ecase x ; Better: will actually catch non-booleans
          ((nil) :bar)) ; Better: matches NIL
          ((t) :quux)) ; Better: matches T
      </CODE_SNIPPET>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="同一性 x 相等性 x 比较">
    <SUMMARY>
      当比较对象时，你应该使用恰当的判断式。
    </SUMMARY>
    <BODY>
      <p>
        Lisp provides four general equality predicates:
        <code>EQ</code>, <code>EQL</code>, <code>EQUAL</code>,
        and <code>EQUALP</code>,
        which subtly vary in semantics.
        Additionally, Lisp provides the type-specific predicates
        <code>=</code>, <code>CHAR=</code>, <code>CHAR-EQUAL</code>,
        <code>STRING=</code>, and <code>STRING-EQUAL</code>.
        Know the distinction!
      </p>
      <p>
        You should use <code>EQL</code> to compare objects and symbols
        for <em>identity</em>.
      </p>
      <p>
        You must not use <code>EQ</code> to compare numbers or characters.
        Two numbers or characters that are <code>EQL</code>
        are not required by Common Lisp to be <code>EQ</code>.
      </p>
      <p>
        When choosing between <code>EQ</code> and <code>EQL</code>,
        you should use <code>EQL</code> unless you are writing
        performance-critical low-level code.
        <code>EQL</code> reduces the opportunity
        for a class of embarrassing errors
        (i.e. if numbers or characters are ever compared).
        There may a tiny performance cost relative to <code>EQ</code>,
        although under SBCL, it often compiles away entirely.
        <code>EQ</code> is equivalent to <code>EQL</code> and type declarations,
        and use of it for optimization should be treated just like
        any such <a href="#Unsafe_Operations">unsafe operations</a>.
      </p>
      <p>
        You should use <code>CHAR=</code>
        for case-dependent character comparisons,
        and <code>CHAR-EQUAL</code> for case-ignoring character comparisons.
      </p>
      <p>
        You should use <code>STRING=</code>
        for case-dependent string comparisons,
        and <code>STRING-EQUAL</code> for case-ignoring string comparisons.
      </p>
      <p>
        A common mistake when using <code>SEARCH</code> on strings
        is to provide <code>STRING=</code> or <code>STRING-EQUAL</code>
        as the <code>:TEST</code> function.
        The <code>:TEST</code> function
        is given two sequence elements to compare.
        If the sequences are strings,
        the <code>:TEST</code> function is called on two characters,
        so the correct tests are <code>CHAR=</code> or <code>CHAR-EQUAL</code>.
        If you use <code>STRING=</code> or <code>STRING-EQUAL</code>,
        the result is what you expect,
        but in some Lisp implementations it's much slower.
        CCL (at least as of 8/2008)
        creates a one-character string upon each comparison, for example,
        which is very expensive.
      </p>
      <p>
        Also, you should use <code>:START</code> and <code>:END</code> arguments
        to <code>STRING=</code> or <code>STRING-EQUAL</code>
        instead of using <code>SUBSEQ</code>;
        e.g. <code>(string-equal (subseq s1 2 6) s2)</code> should instead be
        <code>(string-equal s1 s2 :start1 2 :end1 6)</code>
        This is preferable because it does not cons.
      </p>
      <p>
        You should use <code>ZEROP</code>,
        <code>PLUSP</code>, or <code>MINUSP</code>,
        instead of comparing a value to <code>0</code> or <code>0.0</code>.
      </p>
      <p>
        You must not use exact comparison on floating point numbers,
        since the vague nature of floating point arithmetic
        can produce little "errors" in numeric value.
        You should compare absolute values to a threshhold.
      </p>
      <p>
        You must use <code>=</code> to compare numbers,
        unless you really mean for <code>0</code>,
        <code>0.0</code> and <code>-0.0</code> to compare unequal,
        in which case you should use <code>EQL</code>.
        Then again, you must not usually use exact comparison
        on floating point numbers.
      </p>
      <p>
        Monetary amounts should be using decimal (rational) numbers
        to avoid the complexities and rounding errors
        of floating-point arithmetic.
        Libraries such as
        <a href="http://wukix.com/lisp-decimals">wu-decimal</a>
        may help you;
        once again, if this library is not satisfactory, see above about
        <a href="#Using_Libraries">Using Libraries</a> and
        <a href="#Open-Sourcing_Code">Open-Sourcing Code</a>.
      </p>      
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="迭代">
    <SUMMARY>
      给迭代使用恰当的形式。
    </SUMMARY>
    <BODY>
      <p>
        You should simpler forms such as
        <code>DOLIST</code> or <code>DOTIMES</code>
        instead of <code>LOOP</code>
        in simple cases when you're not going to use any
        of the <code>LOOP</code> facilities such as
        bindings, collection or block return.
      </p>
      <p>
        Use the <code>WITH</code> clause of <code>LOOP</code>
        when it will avoid a level of nesting with <code>LET</code>.
        You may use <code>LET</code> if it makes it clearer
        to return one of bound variables after the <code>LOOP</code>,
        rather than use a clumsy <code>FINALLY (RETURN ...)</code> form.
      </p>
      <p>
        In the body of a <code>DOTIMES</code>,
        do not set the iteration variable.
        (CCL will issue a compiler warning if you do.)
      </p>
      <p>
        Most systems use unadorned symbols in the current package
        as <code>LOOP</code> keywords.
        Other systems use actual <code>:keywords</code>
        from the <code>KEYWORD</code> package
        as <code>LOOP</code> keywords.
        You must be consistent with the convention used in your system.
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="输入与输出">
    <SUMMARY>
      使用恰当的输入与输出函数。
    </SUMMARY>
    <BODY>
      <p>
        When writing a server,
        code must not send output to the standard streams such as
        <code>*STANDARD-OUTPUT*</code> or <code>*ERROR-OUTPUT*</code>.
        Instead, code must use the proper logging framework
        to output messages for debugging.
        We are running as a server, so there is no console!
      </p>
      <p>
        Code must not use <code>PRINT-OBJECT</code>
        to communicate with a user &#8212;
        <code>PRINT-OBJECT</code> is for debugging purposes only.
        Modifying any <code>PRINT-OBJECT</code> method
        must not break any public interfaces.
      </p>
      <p>
        You should not use a sequence of <code>WRITE-XXX</code>
        where a single <code>FORMAT</code> string could be used.
        Using format allows you
        to parameterize the format control string in the future
        if the need arises.
      </p>
      <p>
        You should use <code>WRITE-CHAR</code> to emit a character
        rather than <code>WRITE-STRING</code>
        to emit a single-character string.
      </p>
      <p>
        You should not use <code>(format nil "~A" value)</code>;
        you should use <code>PRINC-TO-STRING</code> instead.
      </p>
      <p>
        You should use <code>~&lt;Newline&gt;</code>
        or <code>~@&lt;Newline&gt;</code> in format strings
        to keep them from wrapping in 100-column editor windows,
        or to indent sections or clauses to make them more readable.
      </p>
      <p>
        You should not use <code>STRING-UPCASE</code>
        or <code>STRING-DOWNCASE</code>
        on format control parameters;
        instead, it should use <code>"~:@(~A~)"</code> or <code>"~(~A~)"</code>.
      </p>
      <p>
        Be careful when using the <code>FORMAT</code> conditional directive.
        The parameters are easy to forget.
      </p>
      <dl>
        <dt>No parameters, e.g. <code>"~[Siamese~;Manx~;Persian~] Cat"</code></dt>
        <dd>
          Take one format argument, which should be an integer.
          Use it to choose a clause. Clause numbers are zero-based.
          If the number is out of range, just print nothing.
          You can provide a default value
          by putting a <code>":"</code> in front of the last <code>";"</code>.
          E.g. in <code>"~[Siamese~;Manx~;Persian~:;Alley~] Cat"</code>,
          an out-of-range arg prints <code>"Alley"</code>.
        </dd>
        <dt><code>:</code> parameter, e.g. <code>"~:[Siamese~;Manx~]"</code></dt>
        <dd>
          Take one format argument.  If it's <code>NIL</code>,
          use the first clause, otherwise use the second clause.
        </dd>
        <dt><code>@</code> parameter, e.g. <code>"~@[Siamese ~a~]"</code></dt>
        <dd>
          If the next format argument is true,
          use the choice, but do NOT take the argument.
          If it's false, take one format argument and print nothing.
          (Normally the clause uses the format argument.)
        </dd>
        <dt><code>#</code> parameter, e.g. <code>"~#[ none~; ~s~; ~s and ~s~]"</code></dt>
        <dd>
          Use the number of arguments to format
          as the number to choose a clause.
          The same as no parameters in all other ways.
          Here's the full hairy example:
          <code>"Items:~#[ none~; ~S~; ~S and ~S~:;~@{~#[~; and~] ~S~^ ,~}~]."</code>
        </dd>
      </dl>
    </BODY>
  </STYLEPOINT>
</CATEGORY>
<CATEGORY title="优化">
  <STYLEPOINT title="避免配置">
    <SUMMARY>
      应该避免配置不必要的内存。
    </SUMMARY>
    <BODY>
      <p>
        In a language with automatic storage management (such as Lisp or Java),
        the colloquial phrase "memory leak" refers to situation
        where storage that is not actually needed
        nevertheless does not get deallocated,
        because it is still reachable.
      </p>
      <p>
        You should be careful that when you create objects,
        you don't leave them reachable after they are no longer needed!
      </p>
      <p>
        Here's a particular trap-for-the-unwary in Common Lisp.
        If you make an array with a fill pointer, and put objects in it,
        and then set the fill pointer back to zero,
        those objects are still reachable as far as Lisp goes
        (the Common Lisp spec says that it's still OK
        to refer to the array entries past the end of the fill pointer).
      </p>
      <p>
        Don't cons (i.e., allocate) unnecessarily.
        Garbage collection is not magic.
        Excessive allocation is usually a performance problem.
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="危险操作">
    <SUMMARY>
      当有明确的性能需求时，绝对只能使用较快的危险操作，
      而你可以记录下来为什么这是对的。
    </SUMMARY>
    <BODY>
      <p>
        Common Lisp implementations often provide backdoors
        to compute some operations faster in an unsafe way.
        For instance, some libraries provide arithmetic operations
        that are designed to be used with fixnums only,
        and yield the correct result faster if provided proper arguments.
        The downside is that the result of such operations
        is incorrect in case of overflow, and can
        have undefined behavior when called with anything but fixnums.
      </p>
      
      <p>
        More generally, unsafe operations
        will yield the correct result faster
        than would the equivalent safe operation
        if the arguments to satisfy some invariant such as
        being of the correct type and small enough;
        however if the arguments fail to satisfy the required invariants,
        then the operation may have undefined behavior,
        such as crashing the software, or,
        which is sometimes worse, silently giving wrong answers.
        Depending on whether the software is piloting an aircraft
        or other life-critical device,
        or whether it is accounting for large amounts money,
        such undefined behavior can kill or bankrupt people.
        Yet proper speed can sometimes make the difference between
        software that's unusably slow and software that does its job;
        between software that is a net loss
        and software that can yield a profit.
      </p>
      <p>
        You must not define or use unsafe operations without both
        profiling results indicating the need for this optimization,
        and careful documentation explaining why it is safe to use them.
        Unsafe operations should be restricted to internal functions;
        you should carefully documented how unsafe it is
        to use these functions with the wrong arguments.
        You should only use unsafe operations
        inside functions internal to a package and
        you should document the use of the declarations,
        since calling the functions with arguments of the wrong type
        can lead to undefined behavior.
        Use <code>check-type</code> in functions exported from a package
        to sanitize input arguments,
        so that internal functions are never passed illegal values.
      </p>
      <p>
        On some compilers,
        new unsafe operations
        can usually be defined by combining
        type declarations with an <code>OPTIMIZE</code> declaration
        that has sufficiently high <code>SPEED</code> and low <code>SAFETY</code>.
        In addition to providing more speed for production code,
        such declarations may more helpful
        than <code>check-type</code> assertions
        for finding bugs at compile-time,
        on compilers that have type inference.
        These compilers may interpret those declarations as assertions
        if you switch to safer and slower optimize settings;
        this is good to locate a dynamic error in your code during development,
        but is not to be used for production code since
        it defeats the purpose of declarations as a performance trick.
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="动态范围">
    <SUMMARY>
      应该只在性能很关键时，使用 <code>DYNAMIC-EXTENT</code>
      而你可以记录下来为什么这是对的。
    </SUMMARY>
    <BODY>
      <p>
        <code>DYNAMIC-EXTENT</code> declaration are
        a particular case of
        <a href="#Unsafe_Operations">unsafe operations</a>.
      </p>
      <p>
        The purpose of the <code>DYNAMIC-EXTENT</code> declaration
        is to improve performance by reducing garbage collection
        in cases where it appears to be obvious that an object's lifetime
        is within the "dynamic extent" of a function.
        That means the object is created at some point
        after the function is called, and
        the object is always inaccessible after the function exits by any means.
      </p>
      <p>
        By declaring a variable or a local function <code>DYNAMIC-EXTENT</code>,
        the programmer <em>asserts</em> to Lisp
        that any object that is ever a value of that variable
        or the closure that is the definition of the function
        has a lifetime within the dynamic extent of the (innermost) function
        that declares the variable.
      </p>
      <p>
        The Lisp implementation is then free to use that information
        to make the program faster.
        Typically, Lisp implementations can take advantage of this knowledge
        to stack-allocate:
      </p>
      <ul>
        <li>
          The lists created to store <code>&amp;REST</code> parameters.
        </li>
        <li>
          Lists and vector allocated within a function.
        </li>
        <li>
          Closures.
        </li>
      </ul>
      <p>
        If the assertion is wrong, i.e. if the programmer's claim is not true,
        the results can be <em>catastrophic</em>:
        Lisp can terminate any time after the function returns,
        or it hang forever, or &#8212; worst of all &#8212;
        produce incorrect results without any runtime error!
      </p>
      <p>
        Even if the assertion is correct,
        future changes to the function might introduce
        a violation of the assertion.
        This increases the danger.
      </p>
      <p>
        In most cases, such objects are ephemeral.
        Modern Lisp implementations use generational garbage collectors,
        which are quite efficient under these circumstances.
      </p>
      <p>
        Therefore, <code>DYNAMIC-EXTENT</code> declarations
        should be used sparingly. You must only use them if:
      </p>
      <ol>
        <li>
          There is some good reason to think that the overall effect
          on performance is noticeable, and
        </li>
        <li>
          It is absolutely clear that the assertion is true.
        </li>
        <li>
          It is quite unlikely that the code will be changed
          in ways that cause the declaration to become false.
        </li>
      </ol>
      <p>
        Point (1) is a special case of
        the principle of avoiding premature optimization.
        An optimization like this only matters if such objects
        are allocated at a very high rate, e.g. "inside an inner loop".
      </p>
      <p>
        Note that is relatively easy to ascertain that
        a function will not escape the dynamic extent of the current call frame
        by analyzing where the function is called and
        what other functions it is passed to;
        therefore, you should somewhat wary of declaring a function
        <code>DYNAMIC-EXTENT</code>, but not a high-stress declaration.
        On the other hand, it is much harder to ascertain that
        none of the objects ever bound or assigned to that variable
        will escape the dynamic extent of the current call frame,
        nor will in any future modification of a function.
        Therefore, you should be extremely wary
        of declaring a variable <code>DYNAMIC-EXTENT</code>.
      </p>
      <p>
        It's sometimes hard to know what the rate will be.
        When writing a function or macro
        that's part of a library of reusable code,
        there's no a priori way to know how often the code will run.
        Ideally, tools would be available to discover
        the availability and suitability of using such an optimization
        based on running simulations and test cases, but
        in practice this isn't as easy as it ought to be.
        It's a tradeoff.
        If you're very, very sure that the assertion is true
        (that the object is only used within the dynamic scope),
        and it's not obvious how much time will be saved
        and it's not easy to measure,
        then it may be better to put in the declaration than to leave it out.
        (Ideally it would be easier to make such measurements
        than it actually is.)
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="应用 x 化简">
    <SUMMARY>
      在适当的场合应该使用 <code>REDUCE</code> 而不是 <code>APPLY</code>。
    </SUMMARY>
    <BODY>
      <p>
        You should use <code>REDUCE</code>
        instead of <code>APPLY</code> and a consed-up list,
        where the semantics of the first operator argument
        otherwise guarantees the same semantics.
        Of course, you must use <code>APPLY</code>
        if it does what you want and <code>REDUCE</code> doesn't.
      </p>
      <p>
        For instance, <code>(apply #'+ (mapcar #'acc frobs)</code>
        should instead be <code>(reduce #'+ frobs :key #'acc)</code>
      </p>
      <p>
        This is preferable because it does not do extra consing,
        and does not risk going beyond <code>CALL-ARGUMENTS-LIMIT</code>
        on implementations where that limit is small,
        which could blow away the stack on long lists
        (we want our code to not be gratuitously unportable).
      </p>
      <p>
        However, you must be careful not to use <code>REDUCE</code>
        in ways that needlessly increase
        the complexity class of the computation.
        For instance, <code>(REDUCE 'STRCAT ...)</code> is <i>O(n^2)</i>
        when an appropriate implementation is only <i>O(n)</i>.
        Moreover, <code>(REDUCE 'APPEND ...)</code>
        is also <i>O(n^2)</i> unless you specify <code>:FROM-END T</code>.
        In such cases, you must use proper abstractions
        that cover those cases instead of calling <code>REDUCE</code>,
        first defining them in a suitable library if need be.
      </p>     
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="避免 NCONC">
    <SUMMARY>
      应该避免使用 <code>NCONC</code>；
      应该使用 <code>APPEND</code> 来取代，或是更好的数据结构。
    </SUMMARY>
    <BODY>
      <p>
        You should almost never use <code>NCONC</code>.
        You should use <code>APPEND</code>
        when you don't depend on any side-effect.
        You should use <code>ALEXANDRIA:APPENDF</code>
        when you need to update a variable.
        You should probably not depend on games
        being played with the <code>CDR</code>
        of the current cons cell;
        and if you do, you must include a prominent
        comment explaining the use of <code>NCONC</code>;
        and you should probably reconsider your data representation.
      </p>
      <p>
        By extension, you should avoid <code>MAPCAN</code>
        or the <code>NCONC</code> feature of <code>LOOP</code>.
        You should instead respectively use
        <code>ALEXANDRIA:MAPPEND</code>
        and the <code>APPEND</code> feature of <code>LOOP</code>
        respectively.
      </p>
      <p>
        <code>NCONC</code> is very seldom a good idea,
        since its time complexity class is no better than <code>APPEND</code>,
        its space complexity class also is no better than <code>APPEND</code>
        in the common case where no one else is sharing the side-effected list,
        and its bug complexity class is way higher than <code>APPEND</code>.
      </p>
      <p>
        If the small performance hit due
        to <code>APPEND</code> vs. <code>NCONC</code>
        is a limiting factor in your program,
        you have a big problem and are probably using the wrong data structure:
        you should be using sequences with constant-time append
        (see Okasaki's book, and add them to lisp-interface-library),
        or more simply you should be accumulating data in a tree
        that will get flattened once in linear time
        after the accumulation phase is complete (see how ASDF does it).
      </p>
      <p>
        You may only use <code>NCONC</code>, <code>MAPCAN</code>
        or the <code>NCONC</code> feature of <code>LOOP</code>
        in low-level functions where performance matters,
        where the use of lists as a data structure has been vetted
        because these lists are known to be short,
        and when the function or expression the result of which are accumulated
        explicitly promises in its contract that it only returns fresh lists.
        Even then, the use of such primitives must be rare,
        and accompanied by justifying documentation.
      </p>
    </BODY>
  </STYLEPOINT>
</CATEGORY>
<CATEGORY title="陷阱">
  <STYLEPOINT title="函数 FUN? 引用 FUN?">
    <SUMMARY>
      你平时应该使用 <code>#'FOO</code> 来引用函数 FOO，
      而不是使用 <code>'FOO</code>。
    </SUMMARY>
    <BODY>
      <p>
        The former, which reads as <code>(FUNCTION FOO)</code>,
        refers to the function object, and is properly scoped.
        The latter, which reads as <code>(QUOTE FOO)</code>,
        refers to the symbol, which when called
        uses the global <code>FDEFINITION</code> of the symbol.
      </p>
      <p>
        When using functions that take a functional argument
        (e.g., <code>MAPCAR</code>, <code>APPLY</code>,
        <code>:TEST</code> and <code>:KEY</code> arguments),
        you should use the <code>#'</code> to quote the function,
        not just single quote.
      </p>
      <p>
        An exception is when you explicitly want dynamic linking,
        because you anticipate that
        the global function binding will be updated.
      </p>
      <p>
        Another exception is when you explicitly want to access
        a global function binding,
        and avoid a possible shadowing lexical binding.
        This shouldn't happen often, as it is usually a bad idea
        to shadow a function when you will want to use the shadowed function;
        just use a different name for the lexical function.
      </p>
      <p>
        You must consistently use either <code>#'(lambda ...)</code>
        or <code>(lambda ...)</code> without <code>#'</code> everywhere.
        Unlike the case of <code>#'symbol</code> vs <code>'symbol</code>,
        it is only a syntactic difference with no semantic impact,
        except that the former works on Genera and the latter doesn't.
        You must use the former style if your code is intended as a library
        with maximal compatibility to all Common Lisp implementations;
        otherwise, it is optional which style you use.
        <code>#'</code> may be seen as a hint
        that you're introducing a function in expression context;
        but the <code>lambda</code> itself is usually sufficient hint,
        and concision is good.
        Choose wisely, but above all,
        consistently with yourself and other developers,
        within a same file, package, system, project, etc.
      </p>
      <p>
        Note that if you start writing a new system
        in a heavily functional style,
        you may consider using
        <a href="http://cliki.net/lambda-reader">lambda-reader</a>,
        a system that lets you use the unicode character <code>&#955;</code>
        instead of <code>LAMBDA</code>.
        But you must not start using such a syntactic extension
        in an existing system without getting permission from other developers.
      </p>
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="路径名">
    <SUMMARY>
      Common Lisp 路径名非常棘手。小心陷阱。
    </SUMMARY>
    <BODY>
      <p>
        It is surprisingly hard to properly deal with pathnames in Common Lisp.
      </p>
      <p>
        First, be aware of the discrepancies between
        the syntax of Common Lisp pathnames,
        which depends on which implementation and operating system
        you are using,
        and the native syntax of pathnames on your operating system.
        The Lisp syntax may involves quoting of special characters
        such as <code>#\.</code> and <code>#\*</code>, etc.,
        in addition to the quoting of
        <code>#\\</code> and <code>#\"</code> within strings.
        By contrast, your operating system's other
        system programming languages
        (shell, C, scripting languages)
        may only have one layer of quoting, into strings.
      </p>
      <p>
        Second, when using <code>MERGE-PATHNAMES</code>,
        be wary of the treatment of the <code>HOST</code> component,
        which matters a lot on non-Unix platforms
        (and even on some Unix implementations).
        You probably should be using
        <code>ASDF-UTILS:MERGE-PATHNAMES*</code>
        instead of <code>MERGE-PATHNAMES</code>,
        especially if your expectations for relative pathnames
        are informed by the way they work in Unix or Windows;
        otherwise you might hit weird bugs whereby on some implementations,
        merging a relative pathnames with an absolute pathname
        results in overriding the absolute pathname's host
        and replace it with the host from the value of
        <code>*DEFAULT-PATHNAME-DEFAULTS*</code>
        at the time the relative pathname was created.
      </p>
      <p>
        Third, be aware that <code>DIRECTORY</code>
        is not portable across implementations
        in how it handles wildcards, sub-directories, symlinks, etc.
        There again, <code>ASDF-UTILS</code> provides several
        common abstractions to deal with pathnames.
      </p>
      <p>
        <code>LOGICAL-PATHNAME</code>s are not a portable abstraction,
        and should not be used in portable code.
        Many implementations have bugs in them, when they are supported at all.
        SBCL implements them very well,
        but strictly enforces the limitations on characters
        allowed by the standard.
        Other implementations allow arbitrary characters in such pathnames,
        but in doing so are not being conformant,
        and are still incompatible with each other in many ways.
        You should use other pathname abstractions,
        such as <code>ASDF:SYSTEM-RELATIVE-PATHNAME</code> or
        the underlying <code>ASDF-UTILS:COERCE-PATHNAME</code>.
      </p>
      
      <p>
        Finally, be aware that paths may change between
        the time you build the Lisp image for your application,
        and the time you run the application from its image.
        You should be careful to reset your image
        to forget irrelevant build-time paths and
        reinitialize any search path from current environment variables.
        <code>ASDF</code> for instance requires you to reset its paths
        with <code>ASDF:CLEAR-CONFIGURATION</code>.
      </p>
      
    </BODY>
  </STYLEPOINT>
  <STYLEPOINT title="满足">
    <SUMMARY>
      在一个类型说明符里使用 <code>SATISFIES</code> 必须非常谨慎。
    </SUMMARY>
    <BODY>
      <p>
        Most Common Lisp implementations can't optimize
        based on a <code>SATISFIES</code> type,
        but many of them offer simple optimizations
        based on a type of the form
        <code>(AND FOO (SATISFIES BAR-P))</code>
        where the first term of the <code>AND</code> clause
        describes the structure of the object
        without any <code>SATISFIES</code>
        and the second term is the <code>SATISFIES</code>.
      </p>
      <BAD_CODE_SNIPPET>
        (deftype prime-number () (satisfies prime-number-p)) ; Bad
      </BAD_CODE_SNIPPET>
      <CODE_SNIPPET>
        (deftype prime-number () (and integer (satisfies prime-number-p)) ; Better
      </CODE_SNIPPET>
      <p>
        However, <code>AND</code> in the <code>DEFTYPE</code> language
        isn't a left-to-right short-circuit operator
        as in the expression language;
        it is a symmetrical connector that allows for reordering subterms
        and doesn't guarantee short-circuiting.
        Therefore, in the above example,
        you cannot rely on the test for <code>INTEGER</code>ness
        to protect the function <code>PRIME-NUMBER-P</code>
        from being supplied non-integer arguments
        to test for being of instances of the type.
        Implementations may, and some <em>will</em>,
        invoke <code>SATISFIES</code>-specified function
        at compile-time to test various relevant objects.
      </p>
      <p>
        That is why any function specified in a <code>SATISFIES</code> clause
        MUST accept objects of any type as argument to the function,
        and MUST be defined within an <code>EVAL-WHEN</code>.
      </p>
      <BAD_CODE_SNIPPET>
        (defun prime-number-p (n) ; Doubly bad!
          (let ((m (abs n)))
            (if (&lt;= m *prime-number-cutoff*)
                (small-prime-number-p m)
                (big-prime-number-p m))))
      </BAD_CODE_SNIPPET>
      <CODE_SNIPPET>
        (eval-when (:compile-toplevel :load-toplevel :execute) ; Better
          (defun prime-number-p (n)
            (when (integerp n) ; Better
              (let ((m (abs n)))
                (if (&lt;= m *prime-number-cutoff*)
                    (small-prime-number-p m)
                    (big-prime-number-p m))))))
      </CODE_SNIPPET>
      <p>
        In particular, the above means that the
        <a href="http://www.lispworks.com/documentation/HyperSpec/Body/t_satisf.htm">example</a>
        used in the Common Lisp Standard is erroneous:
        <code>(and integer (satisfies evenp))</code>
        is <em>not</em> a safe, conformant type specifier to use,
        because <code>EVENP</code> will throw an error
        rather than return <code>NIL</code>
        when passed a non-integer as an argument.
      </p>
      <p>
        Finally, there is a catch when your <code>DEFTYPE</code> code expands
        to a <code>SATISFIES</code> with a dynamically generated function:
      </p>
      <ul>
        <li>
          You cannot control when implementations will or will not
          expand a <code>DEFTYPE</code>.
        </li>
        <li>
          The expansion itself cannot contain a function definition
          or any code in the expression language.
        </li>
        <li>
          You cannot control when the expansion is used,
          it may happen in a different process
          that didn't expand the definition.
        </li>
      </ul>
      <p>
        Therefore, you cannot merely create the function
        as a side-effect of expansion
        using <code>EVAL</code> at type-expansion time.
        The solution is to use
        <code>ASDF-FINALIZERS:EVAL-AT-TOPLEVEL</code> instead.
        See the very last point
        in the discussion about <a href="#EVAL">EVAL</a>.
      </p>
      <p>
        Common Lisp 是很难满足的。
      </p>
    </BODY>
  </STYLEPOINT>
</CATEGORY>

<HR/>

<small>致谢：
   Adam Worrall, Dan Pierson, Matt Marjanovic, Matt Reklaitis,
   Paul Weiss, Scott McKay, Sundar Narasimhan,
   以及其他贡献者。
   特别感谢 Steve Hain 以及先前的编辑者，
   按时间反序排列，他们是 Dan Weinreb 及 Jeremy Brown。
</small>

<p align="right">
修订版号 1.15
</p>


<address>
Robert Brown
</address>

<address>
  <a HREF="mailto:tunes@google.com">Fran&#231;ois-Ren&#233; Rideau</a>
</address>

<p> 
  Report Errors / Suggestions / Comments of Chinese translation: 
  <a HREF="https://github.com/JuanitoFatas/Google-Common-Lisp-Style-Guide/issues">
  Open an issue on Github.
  </a>
</p>

</GUIDE>
